<!DOCTYPE html>
<!--[if IEMobile 7]>
<html class="iem7"  lang="en" dir="ltr"><![endif]-->
<!--[if lte IE 6]>
<html class="lt-ie9 lt-ie8 lt-ie7"  lang="en" dir="ltr"><![endif]-->
<!--[if (IE 7)&(!IEMobile)]>
<html class="lt-ie9 lt-ie8"  lang="en" dir="ltr"><![endif]-->
<!--[if IE 8]>
<html class="lt-ie9"  lang="en" dir="ltr"><![endif]-->
<!--[if IE 9]>
<html class="lt-ie10"  lang="en" dir="ltr" prefix="content: http://purl.org/rss/1.0/modules/content/ dc: http://purl.org/dc/terms/ foaf: http://xmlns.com/foaf/0.1/ og: http://ogp.me/ns# rdfs: http://www.w3.org/2000/01/rdf-schema# sioc: http://rdfs.org/sioc/ns# sioct: http://rdfs.org/sioc/types# skos: http://www.w3.org/2004/02/skos/core# xsd: http://www.w3.org/2001/XMLSchema#"><![endif]-->
<!--[if (gte IE 10)|(gt IEMobile 7)]><!-->
<html lang="en" dir="ltr" prefix="content: http://purl.org/rss/1.0/modules/content/ dc: http://purl.org/dc/terms/ foaf: http://xmlns.com/foaf/0.1/ og: http://ogp.me/ns# rdfs: http://www.w3.org/2000/01/rdf-schema# sioc: http://rdfs.org/sioc/ns# sioct: http://rdfs.org/sioc/types# skos: http://www.w3.org/2004/02/skos/core# xsd: http://www.w3.org/2001/XMLSchema#" class="js js flexbox flexboxlegacy canvas canvastext webgl no-touch geolocation postmessage no-websqldatabase indexeddb hashchange history draganddrop websockets rgba hsla multiplebgs backgroundsize borderimage borderradius boxshadow textshadow opacity cssanimations csscolumns cssgradients no-cssreflections csstransforms csstransforms3d csstransitions fontface generatedcontent video audio localstorage sessionstorage webworkers no-applicationcache svg inlinesvg smil svgclippaths tablesaw-enhanced" style="--wm-toolbar-height: 67px; overflow: visible;"><!--<![endif]--><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><script src="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/utag.js" type="text/javascript" async=""></script><script type="text/javascript" async="" src="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/wap-ssg-intel.js"></script><script src="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/gtm.js" type="text/javascript" async=""></script><script async="" src="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/analytics.js"></script><script src="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/athena.js" type="text/javascript"></script><link type="text/css" rel="stylesheet" id="dark-mode-general-link"><link type="text/css" rel="stylesheet" id="dark-mode-custom-link"><style lang="en" type="text/css" id="dark-mode-custom-style"></style><style lang="en" type="text/css" id="dark-mode-native-style"></style><style lang="en" type="text/css" id="dark-mode-native-sheet"></style>
<script type="text/javascript">window.addEventListener('DOMContentLoaded',function(){var v=archive_analytics.values;v.service='wb';v.server_name='wwwb-app218.us.archive.org';v.server_ms=351;archive_analytics.send_pageview({});});</script>
<script type="text/javascript" src="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/bundle-playback.js" charset="utf-8"></script>
<script type="text/javascript" src="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/wombat.js" charset="utf-8"></script>
<script>window.RufflePlayer=window.RufflePlayer||{};window.RufflePlayer.config={"autoplay":"on","unmuteOverlay":"hidden","showSwfDownload":true};</script>
<script type="text/javascript" src="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/ruffle.js"></script>
<script type="text/javascript">
    __wm.init("https://web.archive.org/web");
  __wm.wombat("https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2","20200503051336","https://web.archive.org/","web","https://web-static.archive.org/_static/",
	      "1588482816");
</script>
<link rel="stylesheet" type="text/css" href="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/banner-styles.css">
<link rel="stylesheet" type="text/css" href="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/iconochive.css">
<!-- End Wayback Rewrite JS Include -->

  <meta charset="utf-8">
<meta property="article:programming_language" content="C/C++">
<meta property="article:skill_level" content="Beginner, Intermediate">
<meta property="article:processor_class" content="Intel® Core™ Processor">
<meta property="article:operating_system" content="Linux*, Microsoft Windows*">
<meta property="article:content_type" content="Code Sample, Tutorial">
<meta property="article:technology" content="OpenGL*, Vulkan*">
<meta property="article:tag" content="Game Development, Graphics">
<script type="application/ld+json">{"@context":"https:\/\/web.archive.org\/web\/20200503051336\/http:\/\/schema.org","mainEntityofPage":"https:\/\/web.archive.org\/web\/20200503051336\/https:\/\/software.intel.com","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https:\/\/web.archive.org\/web\/20200503051336\/https:\/\/software.intel.com\/sites\/default\/files\/managed\/01\/a1\/intel_blue.png","name":"thumbnail","width":"86","height":"60"},"name":"Intel"},"@type":"TechArticle","learningResourceType":"article","headline":"API without Secrets: Introduction to Vulkan* Part 2: Swap Chain","name":"API without Secrets: Introduction to Vulkan* Part 2: Swap Chain","author":{"@type":"Person","name":"Pawel L."},"datePublished":"2016-04-05 09:57:03","dateModified":"2019-11-25 13:50:14","url":"https:\/\/web.archive.org\/web\/20200503051336\/https:\/\/software.intel.com\/articles\/api-without-secrets-introduction-to-vulkan-part-2","image":{"@type":"ImageObject","url":"https:\/\/web.archive.org\/web\/20200503051336\/https:\/\/software.intel.com\/sites\/default\/files\/d9\/e4\/search_publish_icon.jpeg","name":"thumbnail","width":54,"height":54},"inLanguage":"en","description":"","thumbnailURL":"https:\/\/web.archive.org\/web\/20200503051336\/https:\/\/software.intel.com\/sites\/default\/files\/d9\/e4\/search_publish_icon.jpeg","uploadDate":"","operatingSystem":"","applicationCategory":"","audience":"20807,Beginner,20808,Intermediate","genre":[],"keywords":"20787,Linux*,86070,Microsoft Windows*,20802,C\/C++,36920,OpenGL*,86573,Vulkan*,85764,Game Development,20864,Graphics,86469,Gameteam"}</script>
<script type="text/javascript">
//configure analytics
var wa_ssg_data=
{"wa_last_mod_date":"April 5, 2016","wa_ssg_type_macro":"article","wa_ssg_title":"API without Secrets: Introduction to Vulkan* Part 2: Swap Chain","wa_ssg_nid":"623623","wa_ssg_local_code":"en_US","wa_ssg_operating_system":"20787,Linux*,86070,Microsoft Windows*","wa_ssg_programming_language":"20802,C\/C++","wa_ssg_technology":"36920,OpenGL*,86573,Vulkan*","wa_ssg_topic":"85764,Game Development,20864,Graphics","wa_ssg_internal_tags":"86469,Gameteam","wa_ssg_type_micro":"20780,Code Sample,20783,Tutorial"}</script>
<link rel="canonical" href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2">
<script>dataLayer = [{"timestamp":1588475331,"entityType":"node","entityBundle":"article","entityId":"623623","entityLabel":"API without Secrets: Introduction to Vulkan* Part 2: Swap Chain","entityLanguage":"en","entityTnid":"623623","entityVid":"4331642","entityUid":"1183993","entityCreated":"1459875423","entityStatus":"1","entityUuid":"148bd510-baca-48c4-9389-ff098ecd296e","userUuid":"192b3516-0d5e-4e6f-bdc7-df9538ea1665","userInit":"1","drupalLanguage":"en","userUid":0,"systemId":"1","systemName":"idzDrupal"}];</script>
<link rel="shortcut icon" href="https://web.archive.org/web/20200503051336im_/https://software.intel.com/sites/all/themes/zero/favicon.ico" type="image/vnd.microsoft.icon">
<meta property="article:internal_tag" content="Gameteam">
<meta property="article:published_time" content="2019-11-25 21:50:14 UTC">
<meta property="article:last_edit_time" content="2016-04-05 07:00:00 UTC">
<meta property="og:title" content="API without Secrets: Introduction to Vulkan* Part 2: Swap Chain">
<link href="https://web.archive.org/web/20200503051336/https://software.intel.com/zh-cn/articles/api-without-secrets-introduction-to-vulkan-part-2" rel="alternate" hreflang="zh-cn">
<meta property="article:authored_time" content="2016-04-05 16:57:03 UTC">
<meta property="og:description" content="This part discusses swap chain creation. First a set of parameters describing presentation surface is acquired and then proper values for swap chain creation are chosen. Next way to create and record of command buffers is presented (focusing on image layout transitions through image memory barriers). To show that everything works as expected, image is cleared with a arbitrary color. Such image it then presented on the screen. Presentation involves acquiring an image, submitting a command...">
<meta property="og:image" content="https://web.archive.org/web/20200503051336im_/https://software.intel.com/sites/default/files/d9/e4/search_publish_icon.jpeg">
<meta property="article:attachment" content="https://software.intel.com/sites/default/files/managed/99/41/api-without-secrets-introduction-to-vulkan-part-2.pdf">
<meta property="article:body" content="DownloadView PDF [1 MB]Back to: Part 1 The Beginning	Next up: Part 3 First TriangleTutorial 2: Swap Chain – Integrating Vulkan with the OSWelcome to the second Vulkan tutorial. In the first tutorial, I discussed basic Vulkan setup: function loading, instance creation, choosing a physical device and queues, and logical device creation. I'm sure you now want to draw something! Unfortunately we must wait until the next part. Why? Because if we draw something we'll want to see it. Simil...">
<meta property="article:author" content="plapins">
<meta property="article:alias" content="/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2">
<meta property="og:locale" content="en">
<meta name="description" content="This part discusses swap chain creation. First a set of parameters describing presentation surface is acquired and then proper values for swap chain creation are chosen. Next way to create and record of command buffers is presented (focusing on image layout transitions through image memory barriers). To show that everything works as expected, image is cleared with a arbitrary color. Such image it then presented on the screen. Presentation involves acquiring an image, submitting a command buffer, and the presentation process itself.">
<meta name="generator" content="Drupal 7 (http://drupal.org)">
<link rel="shortlink" href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/node/623623">
  <title>API without Secrets: Introduction to Vulkan* Part 2: Swap Chain | Intel® Software</title>

      <meta name="MobileOptimized" content="width">
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="cleartype" content="on">
  <meta property="fb:pages" content="94251532337">

  <link type="text/css" rel="stylesheet" href="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/css_lQaZfjVpwP_oGNqdtWCSpJT1EMqXdMiU84ekLLxQnc4.css" media="all">
<link type="text/css" rel="stylesheet" href="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/css_mxbvRAV0_YoXwGCXbsQzCkegc1pXHICzfd8PPQD9YE4.css" media="all">
<link type="text/css" rel="stylesheet" href="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/css_IMSTIA1KPsPKK4RA7PzUTzLgT5JmOFCO5NTtuQDr9Hk.css" media="all">
<link type="text/css" rel="stylesheet" href="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/css_WlIfyqRNruJMjDkbd0XavOLMVe1z8euF0qBhFKXzKvY.css" media="all">
<link type="text/css" rel="stylesheet" href="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/css_Jy9id_4w7kFC4Xl1Kc8wfVXpRnDHsbIGa1QBCrOkMwU.css" media="all">
  <script src="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/js_qikmINIYTWe4jcTUn8cKiMr8bmSDiZB9LQqvceZ6wlM.js"></script>
<script src="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/js_fDyuIEGrEBqCopqPxfNZo3fOcNiTp5Sr0AKIgjl2qcw.js"></script>
<script src="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/js_CEcULLFTMV4q0ihR85UUYyqfCZWaAFqowXd3xr1wvYI.js"></script>
<script src="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/BrightcoveExperiences.js"></script>
<script src="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/js_3OrdPQ8A2p1O-FiM5cyjfUslA2tDKURNe4ndfamdNGg.js"></script>
<script>(function(i,s,o,g,r,a,m){i["GoogleAnalyticsObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,"script","https://web.archive.org/web/20200503051336/https://www.google-analytics.com/analytics.js","ga");ga("create", "UA-17890616-1", {"cookieDomain":"auto"});var pluginUrl = 
 '//web.archive.org/web/20200503051336/https://www.google-analytics.com/plugins/ga/inpage_linkid.js';
_gaq.push(['_require', 'inpage_linkid', pluginUrl]);
_gaq.push(["_setDomainName", ".intel.com"]);
_gaq.push(["_setAllowLinker", true]);ga("send", "pageview");</script>
<script src="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/js_gpTugKXwQQGP-BdHWjsf2iTkolFwkJUIKHpy0UGMoaM.js"></script>
<script src="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/js_ef7Ow-vB8-SY4eO5QLzxrA-2vqzFTazq4EDPqMRxQvM.js"></script>
<script>jQuery.extend(Drupal.settings, {"basePath":"\/","pathPrefix":"en-us\/","ajaxPageState":{"theme":"zero","theme_token":"jweoITLZ6buvYOj73txL4ZsRp_Mxwn23popshHxC5Cc","js":{"sites\/all\/modules\/custom\/idz_panelizer_widgets\/js\/collapse-list.min.js":1,"sites\/all\/modules\/custom\/idz_search\/js\/idz_search_block.min.js":1,"sites\/all\/modules\/custom\/bds\/resize-twitch.js":1,"sites\/all\/themes\/zero\/js\/language-selector.min.js":1,"sites\/all\/themes\/zero\/js\/mobile-language-selector.min.js":1,"sites\/all\/themes\/zero\/js\/user-dropdown.min.js":1,"sites\/all\/themes\/zero\/js\/collapse-list.min.js":1,"sites\/all\/themes\/zero\/js\/jquery.equalheights.min.js":1,"sites\/all\/themes\/zero\/js\/trunk8.min.js":1,"sites\/all\/themes\/zero\/js\/selectric-runner.min.js":1,"sites\/all\/themes\/zero\/js\/tabs.min.js":1,"sites\/all\/themes\/zero\/js\/gss_search.min.js":1,"sites\/all\/themes\/zero\/js\/comments.min.js":1,"sites\/all\/themes\/zero\/js\/user-login.min.js":1,"sites\/all\/themes\/zero\/js\/faq.min.js":1,"sites\/all\/themes\/zero\/js\/combobox.min.js":1,"sites\/all\/themes\/zero\/js\/comparison-tables.min.js":1,"sites\/all\/themes\/zero\/js\/simple-toggle.min.js":1,"sites\/all\/themes\/zero\/js\/rateus.min.js":1,"sites\/all\/themes\/zero\/js\/tabgroup.min.js":1,"sites\/all\/modules\/custom\/idz_zero\/js\/idz_zero.min.js":1,"sites\/all\/themes\/zero\/js\/comment-form-resizer.min.js":1,"misc\/jquery.js":1,"misc\/jquery-extend-3.4.0.js":1,"misc\/jquery.once.js":1,"misc\/drupal.js":1,"misc\/ui\/jquery.ui.core.min.js":1,"misc\/ui\/jquery.ui.widget.min.js":1,"misc\/ui\/jquery.ui.position.min.js":1,"misc\/ui\/jquery.ui.autocomplete.min.js":1,"sites\/all\/modules\/contrib\/dhtml_menu\/dhtml_menu.js":1,"sites\/all\/modules\/contrib\/gss\/scripts\/autocomplete.js":1,"sites\/all\/modules\/custom\/intel_belt_rewards\/intel_belt_rewards.js":1,"sites\/all\/modules\/custom\/social_block\/social-block.min.js":1,"https:\/\/web.archive.org\/web\/20200503051336\/https:\/\/sadmin.brightcove.com\/js\/BrightcoveExperiences.js":1,"sites\/all\/modules\/contrib\/quote\/quote.js":1,"sites\/all\/modules\/contrib\/google_analytics\/googleanalytics.js":1,"0":1,"sites\/all\/themes\/zero\/js\/intel-filter.min.js":1,"sites\/all\/modules\/contrib\/datalayer\/js\/getCanonical.js":1,"sites\/all\/themes\/zero\/js\/script.min.js":1,"sites\/all\/themes\/zero\/js\/vendors\/jquery\/jquery-1.10.2.min.js":1,"sites\/all\/themes\/zero\/js\/plugins\/jquery.selectric.min.js":1,"sites\/all\/themes\/zero\/js\/plugins\/jquery.inview.min.js":1,"sites\/all\/themes\/zero\/js\/plugins\/jquery.breakpoint.min.js":1,"sites\/all\/themes\/zero\/js\/plugins\/jquery.magnific-popup.js":1,"sites\/all\/themes\/zero\/js\/plugins\/jquery.waypoints.min.js":1,"sites\/all\/themes\/zero\/js\/jquery-noconflict.min.js":1,"sites\/all\/themes\/zero\/js\/vendors\/jquery\/modernizr.min.js":1,"sites\/all\/themes\/zero\/js\/zero-init.min.js":1,"sites\/all\/themes\/zero\/js\/zero-common.min.js":1,"sites\/all\/themes\/zero\/js\/zero-breakpoints.min.js":1,"sites\/all\/themes\/zero\/js\/brushes\/syntaxhighlighter\/scripts\/shCore.min.js":1,"sites\/all\/themes\/zero\/js\/brushes\/syntaxhighlighter\/scripts\/shBrushBash.min.js":1,"sites\/all\/themes\/zero\/js\/brushes\/syntaxhighlighter\/scripts\/shBrushCpp.min.js":1,"sites\/all\/themes\/zero\/js\/brushes\/syntaxhighlighter\/scripts\/shBrushCSharp.min.js":1,"sites\/all\/themes\/zero\/js\/brushes\/syntaxhighlighter\/scripts\/shBrushCss.min.js":1,"sites\/all\/themes\/zero\/js\/brushes\/syntaxhighlighter\/scripts\/shBrushFortran.min.js":1,"sites\/all\/themes\/zero\/js\/brushes\/syntaxhighlighter\/scripts\/shBrushJava.min.js":1,"sites\/all\/themes\/zero\/js\/brushes\/syntaxhighlighter\/scripts\/shBrushJScript.min.js":1,"sites\/all\/themes\/zero\/js\/brushes\/syntaxhighlighter\/scripts\/shBrushPerl.min.js":1,"sites\/all\/themes\/zero\/js\/brushes\/syntaxhighlighter\/scripts\/shBrushPhp.min.js":1,"sites\/all\/themes\/zero\/js\/brushes\/syntaxhighlighter\/scripts\/shBrushPlain.min.js":1,"sites\/all\/themes\/zero\/js\/brushes\/syntaxhighlighter\/scripts\/shBrushPython.min.js":1,"sites\/all\/themes\/zero\/js\/brushes\/syntaxhighlighter\/scripts\/shBrushR.min.js":1,"sites\/all\/themes\/zero\/js\/brushes\/syntaxhighlighter\/scripts\/shBrushRuby.min.js":1,"sites\/all\/themes\/zero\/js\/brushes\/syntaxhighlighter\/scripts\/shBrushSql.min.js":1,"sites\/all\/themes\/zero\/js\/brushes\/syntaxhighlighter\/scripts\/shBrushXml.min.js":1},"css":{"modules\/system\/system.base.css":1,"modules\/system\/system.menus.css":1,"modules\/system\/system.messages.css":1,"modules\/system\/system.theme.css":1,"misc\/ui\/jquery.ui.core.css":1,"misc\/ui\/jquery.ui.theme.css":1,"misc\/ui\/jquery.ui.autocomplete.css":1,"sites\/all\/modules\/custom\/bds\/bds.css":1,"modules\/book\/book.css":1,"sites\/all\/modules\/contrib\/calendar\/css\/calendar_multiday.css":1,"modules\/comment\/comment.css":1,"sites\/all\/modules\/contrib\/date\/date_api\/date.css":1,"sites\/all\/modules\/contrib\/date\/date_popup\/themes\/datepicker.1.7.css":1,"sites\/all\/modules\/contrib\/dhtml_menu\/dhtml_menu.css":1,"modules\/field\/theme\/field.css":1,"sites\/all\/modules\/custom\/intel_advanced_forum_style\/styles\/idz\/advanced-forum.idz.images.css":1,"sites\/all\/modules\/custom\/intel_advanced_forum_style\/styles\/idz\/advanced-forum.idz.structure.css":1,"modules\/node\/node.css":1,"sites\/all\/modules\/custom\/node_attachments_block\/node-attachments-block.less.css":1,"modules\/search\/search.css":1,"sites\/all\/modules\/custom\/social_block\/social-block.less.css":1,"modules\/user\/user.css":1,"modules\/forum\/forum.css":1,"sites\/all\/modules\/contrib\/views\/css\/views.css":1,"sites\/all\/modules\/contrib\/ctools\/css\/ctools.css":1,"sites\/all\/modules\/contrib\/panels\/css\/panels.css":1,"sites\/all\/modules\/contrib\/quote\/quote.css":1,"sites\/all\/modules\/custom\/idz_panelizer_widgets\/css\/collapse-list.css":1,"modules\/contextual\/contextual.css":1,"modules\/locale\/locale.css":1,"sites\/all\/themes\/zero\/js\/brushes\/syntaxhighlighter\/styles\/shThemeIntel.css":1,"sites\/all\/modules\/custom\/idz_zero\/css\/idz_zero.css":1,"sites\/all\/themes\/zero\/system.menus.css":1,"sites\/all\/themes\/zero\/system.messages.css":1,"sites\/all\/themes\/zero\/system.theme.css":1,"sites\/all\/themes\/zero\/css\/export.css":1,"sites\/all\/themes\/zero\/css\/styles.css":1,"sites\/all\/themes\/zero\/js\/brushes\/syntaxhighlighter\/styles\/shCore.css":1,"sites\/all\/themes\/zero\/js\/brushes\/syntaxhighlighter\/styles\/shThemeRDark.css":1}},"dhtmlMenu":{"nav":"bullet","animation":{"effects":{"height":"height","opacity":"opacity","width":0},"speed":"500"},"effects":{"siblings":"close-same-tree","children":"none","remember":""},"filter":{"type":"blacklist","list":{"main-menu":"main-menu","management":"management","menu--firmware":"menu--firmware","menu--graphics-processing-resear":"menu--graphics-processing-resear","menu--storage":"menu--storage","menu--storage-second-footer":"menu--storage-second-footer","menu-advisor":"menu-advisor","menu-advisor-second-menu":"menu-advisor-second-menu","menu-ai-frameworks":"menu-ai-frameworks","menu-ai-frameworks-second-footer":"menu-ai-frameworks-second-footer","menu-android-resources":"menu-android-resources","menu-auto-driving-second-footer":"menu-auto-driving-second-footer","menu-automated-driving":"menu-automated-driving","menu-bi-endian-technology":"menu-bi-endian-technology","menu-business-client":"menu-business-client","menu-cluster-checker":"menu-cluster-checker","menu-cluster-checker-second-foot":"menu-cluster-checker-second-foot","menu-collaboration-suite-for-web":"menu-collaboration-suite-for-web","menu-computer-vision-sdk":"menu-computer-vision-sdk","menu-computer-vision-sdk-footer":"menu-computer-vision-sdk-footer","menu-cpu-runtime-for-opencl-appl":"menu-cpu-runtime-for-opencl-appl","menu-daal":"menu-daal","menu-dal":"menu-dal","menu-data-center":"menu-data-center","menu-data-center-second-footer":"menu-data-center-second-footer","menu-dev-api-second-footer":"menu-dev-api-second-footer","menu-devcloud":"menu-devcloud","menu-devcloud-footer":"menu-devcloud-footer","menu-development-tools":"menu-development-tools","menu-dx-second-footer":"menu-dx-second-footer","menu-footer-for-bi-endian-techno":"menu-footer-for-bi-endian-techno","menu-footer-for-intel-software-g":"menu-footer-for-intel-software-g","menu-footer-for-intel-trace-anal":"menu-footer-for-intel-trace-anal","menu-footer-intel-pal":"menu-footer-intel-pal","menu-footer-intel-tbb":"menu-footer-intel-tbb","menu-footer-menu-for-intel-activ":"menu-footer-menu-for-intel-activ","menu-footer-menu-for-intel-sdk-f":"menu-footer-menu-for-intel-sdk-f","menu-footer-menu-for-intel-unite":"menu-footer-menu-for-intel-unite","menu-fpga-academic":"menu-fpga-academic","menu-fpga-second-footer":"menu-fpga-second-footer","menu-game-dev":"menu-game-dev","menu-game-dev-second-footer":"menu-game-dev-second-footer","menu-gpa":"menu-gpa","menu-gpa-second-footer":"menu-gpa-second-footer","menu-home":"menu-home","menu-home-second-footer":"menu-home-second-footer","menu-hpc-containers-from-intel":"menu-hpc-containers-from-intel","menu-inspector-menu":"menu-inspector-menu","menu-inspector-second-footer":"menu-inspector-second-footer","menu-intel-active-management-tec":"menu-intel-active-management-tec","menu-intel-aero":"menu-intel-aero","menu-intel-aero-second-footer":"menu-intel-aero-second-footer","menu-intel-c-compiler":"menu-intel-c-compiler","menu-intel-c-compiler-footer-men":"menu-intel-c-compiler-footer-men","menu-intel-compilers":"menu-intel-compilers","menu-intel-daal-second-footer":"menu-intel-daal-second-footer","menu-intel-dist-for-pyth":"menu-intel-dist-for-pyth","menu-intel-fortran-compiler":"menu-intel-fortran-compiler","menu-intel-fortran-compiler-foot":"menu-intel-fortran-compiler-foot","menu-intel-ipp":"menu-intel-ipp","menu-intel-ipp-second-footer":"menu-intel-ipp-second-footer","menu-intel-media-sdk":"menu-intel-media-sdk","menu-intel-mkl":"menu-intel-mkl","menu-intel-mkl-second-footer":"menu-intel-mkl-second-footer","menu-intel-realsense-technology":"menu-intel-realsense-technology","menu-intel-sdk-for-opencl-applic":"menu-intel-sdk-for-opencl-applic","menu-intel-secure-device-onboard":"menu-intel-secure-device-onboard","menu-intel-security-dev-api":"menu-intel-security-dev-api","menu-intel-software-guard-extens":"menu-intel-software-guard-extens","menu-intel-system-studio":"menu-intel-system-studio","menu-intel-tbb":"menu-intel-tbb","menu-intel-trace-analyzer-and-co":"menu-intel-trace-analyzer-and-co","menu-intel-unite-plugin-software":"menu-intel-unite-plugin-software","menu-iot":"menu-iot","menu-iot-second-footer":"menu-iot-second-footer","menu-ipsxe":"menu-ipsxe","menu-ipsxe-second-footer":"menu-ipsxe-second-footer","menu-isa-l":"menu-isa-l","menu-isa-l-second-footer":"menu-isa-l-second-footer","menu-iss-second-footer":"menu-iss-second-footer","menu-machine-learning":"menu-machine-learning","menu-machine-learning-second-foo":"menu-machine-learning-second-foo","menu-media-sdk-second-footer":"menu-media-sdk-second-footer","menu-meet-the-developers":"menu-meet-the-developers","menu-menu-intel-pal":"menu-menu-intel-pal","menu-menu-whatsit":"menu-menu-whatsit","menu-modern-code":"menu-modern-code","menu-modern-code-second-footer":"menu-modern-code-second-footer","menu-movidius-ncs":"menu-movidius-ncs","menu-movidius-ncs-second-footer":"menu-movidius-ncs-second-footer","menu-mpi-library":"menu-mpi-library","menu-mpi-library-second-footer":"menu-mpi-library-second-footer","menu-networking":"menu-networking","menu-networking-second-footer":"menu-networking-second-footer","menu-openvino-toolkit":"menu-openvino-toolkit","menu-openvino-toolkit-second-foo":"menu-openvino-toolkit-second-foo","menu-performance-snapshot":"menu-performance-snapshot","menu-persistent-memory":"menu-persistent-memory","menu-persistent-memory-second-fo":"menu-persistent-memory-second-fo","menu-python-second-footer":"menu-python-second-footer","menu-realsense-tech-second-foot":"menu-realsense-tech-second-foot","menu-saffron-second-footer":"menu-saffron-second-footer","menu-second-footer-cpu-runtime":"menu-second-footer-cpu-runtime","menu-second-footer-for-intel-tru":"menu-second-footer-for-intel-tru","menu-test-ai-menu":"menu-test-ai-menu","menu-test-second-footer":"menu-test-second-footer","menu-time-coordinated-computing":"menu-time-coordinated-computing","menu-topics-technologies":"menu-topics-technologies","menu-useful-packages-modules":"menu-useful-packages-modules","menu-ux-main-menu":"menu-ux-main-menu","menu-virtual-reality":"menu-virtual-reality","menu-virtual-reality-second-foot":"menu-virtual-reality-second-foot","menu-vtune":"menu-vtune","menu-vtune-second-footer":"menu-vtune-second-footer","menu-webrtc-second-footer":"menu-webrtc-second-footer","menu-whats-it-footer":"menu-whats-it-footer","menu-windows":"menu-windows","menu-windows-second-footer":"menu-windows-second-footer","menu-xeon-phi-processor":"menu-xeon-phi-processor","navigation":"navigation","shortcut-set-1":"shortcut-set-1","user-menu":"user-menu","book-toc-401277":0,"book-toc-438058":0,"book-toc-468328":0,"book-toc-471718":0,"book-toc-473525":0,"book-toc-473527":0,"book-toc-474337":0,"book-toc-474339":0,"book-toc-487631":0,"book-toc-498033":0,"book-toc-498423":0,"book-toc-498595":0,"book-toc-498939":0,"book-toc-498954":0,"book-toc-499050":0,"book-toc-501640":0,"book-toc-501977":0,"book-toc-501979":0,"book-toc-501980":0,"book-toc-501994":0,"book-toc-502751":0,"book-toc-503882":0,"book-toc-505525":0,"book-toc-506039":0,"book-toc-507032":0,"book-toc-507536":0,"book-toc-515758":0,"book-toc-517758":0,"book-toc-519946":0,"book-toc-520075":0,"book-toc-520076":0,"book-toc-520699":0,"book-toc-522349":0,"book-toc-522354":0,"book-toc-522437":0,"book-toc-522750":0,"book-toc-522753":0,"book-toc-522755":0,"book-toc-522758":0,"book-toc-522774":0,"book-toc-522786":0,"book-toc-528316":0,"book-toc-528318":0,"book-toc-528490":0,"book-toc-528650":0,"book-toc-528760":0,"book-toc-528852":0,"book-toc-529109":0,"book-toc-529730":0,"book-toc-530757":0,"book-toc-531234":0,"book-toc-534201":0,"book-toc-534265":0,"book-toc-534451":0,"book-toc-534454":0,"book-toc-534455":0,"book-toc-535292":0,"book-toc-535512":0,"book-toc-535564":0,"book-toc-539278":0,"book-toc-539988":0,"book-toc-540373":0,"book-toc-540374":0,"book-toc-540375":0,"book-toc-540376":0,"book-toc-540377":0,"book-toc-540499":0,"book-toc-540565":0,"book-toc-540664":0,"book-toc-541291":0,"book-toc-543885":0,"book-toc-544575":0,"book-toc-551014":0,"book-toc-558501":0,"book-toc-558502":0,"book-toc-561188":0,"book-toc-561203":0,"book-toc-561218":0,"book-toc-561269":0,"book-toc-561457":0,"book-toc-561592":0,"book-toc-561831":0,"book-toc-561846":0,"book-toc-561866":0,"book-toc-561885":0,"book-toc-562383":0,"book-toc-564482":0,"book-toc-564572":0,"book-toc-564573":0,"book-toc-565519":0,"book-toc-565530":0,"book-toc-566133":0,"book-toc-566144":0,"book-toc-566726":0,"book-toc-566739":0,"book-toc-567641":0,"book-toc-567642":0,"book-toc-567643":0,"book-toc-567645":0,"book-toc-567646":0,"book-toc-569961":0,"book-toc-569963":0,"book-toc-584151":0,"book-toc-584152":0,"book-toc-584153":0,"book-toc-584154":0,"book-toc-584155":0,"book-toc-584156":0,"book-toc-584159":0,"book-toc-584182":0,"book-toc-584183":0,"book-toc-584185":0,"book-toc-586153":0,"book-toc-586154":0,"book-toc-586166":0,"book-toc-587354":0,"book-toc-587395":0,"book-toc-587399":0,"book-toc-587422":0,"book-toc-587431":0,"book-toc-587454":0,"book-toc-587463":0,"book-toc-587464":0,"book-toc-587486":0,"book-toc-587487":0,"book-toc-587489":0,"book-toc-587495":0,"book-toc-587504":0,"book-toc-587510":0,"book-toc-587542":0,"book-toc-587599":0,"book-toc-587604":0,"book-toc-587607":0,"book-toc-587629":0,"book-toc-587631":0,"book-toc-587633":0,"book-toc-587773":0,"book-toc-587776":0,"book-toc-587779":0,"book-toc-587781":0,"book-toc-587790":0,"book-toc-587853":0,"book-toc-587885":0,"book-toc-587916":0,"book-toc-587917":0,"book-toc-587919":0,"book-toc-587922":0,"book-toc-587924":0,"book-toc-587996":0,"book-toc-588028":0,"book-toc-588060":0,"book-toc-588067":0,"book-toc-588073":0,"book-toc-588172":0,"book-toc-588204":0,"book-toc-588210":0,"book-toc-588216":0,"book-toc-588217":0,"book-toc-588218":0,"book-toc-588313":0,"book-toc-588315":0,"book-toc-588345":0,"book-toc-588347":0,"book-toc-588353":0,"book-toc-588359":0,"book-toc-588360":0,"book-toc-588361":0,"book-toc-588392":0,"book-toc-588424":0,"book-toc-588458":0,"book-toc-588460":0,"book-toc-588576":0,"book-toc-588600":0,"book-toc-588606":0,"book-toc-588607":0,"book-toc-588638":0,"book-toc-588663":0,"book-toc-588743":0,"book-toc-588749":0,"book-toc-588781":0,"book-toc-588806":0,"book-toc-588886":0,"book-toc-588892":0,"book-toc-588893":0,"book-toc-589029":0,"book-toc-589035":0,"book-toc-589067":0,"book-toc-589092":0,"book-toc-589099":0,"book-toc-589145":0,"book-toc-589172":0,"book-toc-589178":0,"book-toc-589210":0,"book-toc-589235":0,"book-toc-589242":0,"book-toc-589288":0,"book-toc-589321":0,"book-toc-589353":0,"book-toc-589378":0,"book-toc-589385":0,"book-toc-589431":0,"book-toc-589483":0,"book-toc-589521":0,"book-toc-589568":0,"book-toc-589574":0,"book-toc-590353":0,"book-toc-591972":0,"book-toc-592487":0,"book-toc-594272":0,"book-toc-594555":0,"book-toc-595378":0,"book-toc-597167":0,"book-toc-598097":0,"book-toc-600044":0,"book-toc-603207":0,"book-toc-603220":0,"book-toc-604281":0,"book-toc-604531":0,"book-toc-604532":0,"book-toc-608061":0,"book-toc-608069":0,"book-toc-608085":0,"book-toc-608125":0,"book-toc-608133":0,"book-toc-608141":0,"book-toc-608149":0,"book-toc-608206":0,"book-toc-608214":0,"book-toc-608242":0,"book-toc-608270":0,"book-toc-608295":0,"book-toc-608346":0,"book-toc-608394":0,"book-toc-608418":0,"book-toc-608419":0,"book-toc-608474":0,"book-toc-608522":0,"book-toc-608546":0,"book-toc-608547":0,"book-toc-608614":0,"book-toc-608658":0,"book-toc-608678":0,"book-toc-608694":0,"book-toc-608723":0,"book-toc-608727":0,"book-toc-608743":0,"book-toc-608787":0,"book-toc-608799":0,"book-toc-608807":0,"book-toc-608851":0,"book-toc-608863":0,"book-toc-608871":0,"book-toc-610445":0,"book-toc-610465":0,"book-toc-610591":0,"book-toc-610914":0,"book-toc-611630":0,"book-toc-622387":0,"book-toc-622642":0,"book-toc-624484":0,"book-toc-624486":0,"book-toc-624488":0,"book-toc-624493":0,"book-toc-624506":0,"book-toc-628408":0,"book-toc-628730":0,"book-toc-628866":0,"book-toc-628966":0,"book-toc-629122":0,"book-toc-631691":0,"book-toc-631722":0,"book-toc-631734":0,"book-toc-631755":0,"book-toc-631786":0,"book-toc-631798":0,"book-toc-631819":0,"book-toc-631850":0,"book-toc-631862":0,"book-toc-631915":0,"book-toc-631948":0,"book-toc-631979":0,"book-toc-632012":0,"book-toc-632043":0,"book-toc-632045":0,"book-toc-632107":0,"book-toc-632109":0,"book-toc-632284":0,"book-toc-632317":0,"book-toc-632348":0,"book-toc-632381":0,"book-toc-632876":0,"book-toc-632892":0,"book-toc-632909":0,"book-toc-632941":0,"book-toc-632958":0,"book-toc-633005":0,"book-toc-633022":0,"book-toc-633069":0,"book-toc-633087":0,"book-toc-633281":0,"book-toc-639647":0,"book-toc-645821":0,"book-toc-645824":0,"book-toc-645837":0,"book-toc-645873":0,"book-toc-645903":0,"book-toc-645904":0,"book-toc-645950":0,"book-toc-645967":0,"book-toc-646014":0,"book-toc-646031":0,"book-toc-646078":0,"book-toc-656652":0,"book-toc-656666":0,"book-toc-661300":0,"book-toc-661302":0,"book-toc-661307":0,"book-toc-661364":0,"book-toc-661366":0,"book-toc-661371":0,"book-toc-661377":0,"book-toc-661428":0,"book-toc-661430":0,"book-toc-661435":0,"book-toc-661441":0,"book-toc-661492":0,"book-toc-661494":0,"book-toc-661505":0,"book-toc-661519":0,"book-toc-661523":0,"book-toc-661552":0,"book-toc-661555":0,"book-toc-661558":0,"book-toc-661563":0,"book-toc-661564":0,"book-toc-661605":0,"book-toc-661616":0,"book-toc-661669":0,"book-toc-661684":0,"book-toc-661692":0,"book-toc-661698":0,"book-toc-661733":0,"book-toc-661735":0,"book-toc-661748":0,"book-toc-661756":0,"book-toc-661762":0,"book-toc-661937":0,"book-toc-661941":0,"book-toc-661949":0,"book-toc-661955":0,"book-toc-662005":0,"book-toc-662013":0,"book-toc-662019":0,"book-toc-662066":0,"book-toc-662069":0,"book-toc-662072":0,"book-toc-662078":0,"book-toc-662103":0,"book-toc-662130":0,"book-toc-662133":0,"book-toc-662136":0,"book-toc-662142":0,"book-toc-662148":0,"book-toc-662167":0,"book-toc-670509":0,"book-toc-670512":0,"book-toc-670521":0,"book-toc-670527":0,"book-toc-670546":0,"book-toc-670548":0,"book-toc-670576":0,"book-toc-670577":0,"book-toc-670585":0,"book-toc-670591":0,"book-toc-670610":0,"book-toc-670638":0,"book-toc-670641":0,"book-toc-670702":0,"book-toc-670705":0,"book-toc-670708":0,"book-toc-670720":0,"book-toc-670766":0,"book-toc-670769":0,"book-toc-670784":0,"book-toc-670833":0,"book-toc-670848":0,"book-toc-670895":0,"book-toc-670898":0,"book-toc-670959":0,"book-toc-670962":0,"book-toc-671023":0,"book-toc-671026":0,"book-toc-671090":0,"book-toc-671152":0,"book-toc-671180":0,"book-toc-671186":0,"book-toc-672403":0,"book-toc-672529":0,"book-toc-672535":0,"book-toc-674861":0,"book-toc-676253":0,"book-toc-676255":0,"book-toc-676257":0,"book-toc-676261":0,"book-toc-676262":0,"book-toc-676264":0,"book-toc-676427":0,"book-toc-676459":0,"book-toc-676540":0,"book-toc-676604":0,"book-toc-676669":0,"book-toc-676685":0,"book-toc-676706":0,"book-toc-681616":0,"book-toc-681618":0,"book-toc-681911":0,"book-toc-681916":0,"book-toc-685375":0,"book-toc-696094":0,"book-toc-696906":0,"book-toc-699541":0,"book-toc-701415":0,"book-toc-701542":0,"book-toc-702404":0,"book-toc-702468":0,"book-toc-703101":0,"book-toc-704752":0,"book-toc-705714":0,"book-toc-705778":0,"book-toc-707344":0,"book-toc-711193":0,"book-toc-712883":0,"book-toc-712937":0,"book-toc-712966":0,"book-toc-713788":0,"book-toc-713910":0,"book-toc-713974":0,"book-toc-714038":0,"book-toc-714118":0,"book-toc-714158":0,"book-toc-714167":0,"book-toc-714183":0,"book-toc-714222":0,"book-toc-714231":0,"book-toc-714247":0,"book-toc-714295":0,"book-toc-714302":0,"book-toc-714311":0,"book-toc-714368":0,"book-toc-714432":0,"book-toc-714496":0,"book-toc-714560":0,"book-toc-714605":0,"book-toc-714685":0,"book-toc-717511":0,"book-toc-717512":0,"book-toc-720369":0,"book-toc-720718":0,"book-toc-721119":0,"book-toc-721395":0,"book-toc-721433":0,"book-toc-721564":0,"book-toc-722243":0,"book-toc-722458":0,"book-toc-722460":0,"book-toc-722465":0,"book-toc-722466":0,"book-toc-722467":0,"book-toc-722468":0,"book-toc-722524":0,"book-toc-724083":0,"book-toc-724115":0,"book-toc-724116":0,"book-toc-724117":0,"book-toc-724552":0,"book-toc-724553":0,"book-toc-724554":0,"book-toc-724599":0,"book-toc-731066":0,"book-toc-731067":0,"book-toc-733361":0,"book-toc-733378":0,"book-toc-735072":0,"book-toc-735382":0,"book-toc-735854":0,"book-toc-737016":0,"book-toc-737243":0,"book-toc-737282":0,"book-toc-737312":0,"book-toc-737456":0,"book-toc-737481":0,"book-toc-738158":0,"book-toc-740721":0,"book-toc-741434":0,"book-toc-742008":0,"book-toc-743107":0,"book-toc-743241":0,"book-toc-743254":0,"book-toc-743305":0,"book-toc-743335":0,"book-toc-743698":0,"book-toc-743723":0,"book-toc-743742":0,"book-toc-744050":0,"book-toc-744051":0,"book-toc-744355":0,"book-toc-744368":0,"book-toc-744394":0,"book-toc-744483":0,"book-toc-744547":0,"book-toc-744666":0,"book-toc-744708":0,"book-toc-745781":0,"book-toc-745794":0,"book-toc-745809":0,"book-toc-745815":0,"book-toc-745826":0,"book-toc-745832":0,"book-toc-745838":0,"book-toc-745857":0,"book-toc-745869":0,"book-toc-745877":0,"book-toc-745883":0,"book-toc-745890":0,"book-toc-745911":0,"book-toc-746171":0,"book-toc-746883":0,"book-toc-746991":0,"book-toc-747537":0,"book-toc-747737":0,"book-toc-748161":0,"book-toc-748987":0,"book-toc-749391":0,"book-toc-754724":0,"book-toc-754929":0,"book-toc-755770":0,"book-toc-757959":0,"book-toc-759136":0,"book-toc-759195":0,"book-toc-759336":0,"book-toc-760652":0,"book-toc-760671":0,"book-toc-760820":0,"book-toc-762840":0,"book-toc-762880":0,"book-toc-763183":0,"book-toc-763317":0,"book-toc-765163":0,"book-toc-765165":0,"book-toc-765182":0,"book-toc-765184":0,"book-toc-765191":0,"book-toc-765193":0,"book-toc-765210":0,"book-toc-765249":0,"book-toc-765253":0,"book-toc-767649":0,"book-toc-767803":0,"book-toc-768356":0,"book-toc-769010":0,"book-toc-769030":0,"book-toc-769074":0,"book-toc-769094":0,"book-toc-769138":0,"book-toc-769154":0,"book-toc-769158":0,"book-toc-769202":0,"book-toc-769218":0,"book-toc-769267":0,"book-toc-769303":0,"book-toc-769311":0,"book-toc-769323":0,"book-toc-769331":0,"book-toc-769368":0,"book-toc-769376":0,"book-toc-769388":0,"book-toc-769396":0,"book-toc-769463":0,"book-toc-769528":0,"book-toc-769529":0,"book-toc-769530":0,"book-toc-769531":0,"book-toc-769534":0,"book-toc-776512":0,"book-toc-776660":0,"book-toc-776770":0,"book-toc-776798":0,"book-toc-777111":0,"book-toc-777117":0,"book-toc-777163":0,"book-toc-777750":0,"book-toc-777839":0,"book-toc-778017":0,"book-toc-778108":0,"book-toc-778113":0,"book-toc-778168":0,"book-toc-778232":0,"book-toc-778236":0,"book-toc-778257":0,"book-toc-778296":0,"book-toc-778321":0,"book-toc-778333":0,"book-toc-778370":0,"book-toc-778377":0,"book-toc-778397":0,"book-toc-779040":0,"book-toc-779407":0,"book-toc-779475":0,"book-toc-779508":0,"book-toc-779626":0,"book-toc-779640":0,"book-toc-779819":0,"book-toc-780207":0,"book-toc-780875":0,"book-toc-780876":0,"book-toc-781306":0,"book-toc-781348":0,"book-toc-781364":0,"book-toc-781386":0,"book-toc-781412":0,"book-toc-781428":0,"book-toc-781450":0,"book-toc-781476":0,"book-toc-781492":0,"book-toc-781525":0,"book-toc-781661":0,"book-toc-782010":0,"book-toc-782236":0,"book-toc-782801":0,"book-toc-782871":0,"book-toc-782990":0,"book-toc-790641":0,"book-toc-793554":0,"book-toc-795979":0,"book-toc-796341":0,"book-toc-796344":0,"book-toc-796346":0,"book-toc-796348":0,"book-toc-796351":0,"book-toc-796353":0,"book-toc-796560":0,"book-toc-797056":0,"book-toc-797065":0,"book-toc-797097":0,"book-toc-797101":0,"book-toc-797216":0,"book-toc-797224":0,"book-toc-797297":0,"book-toc-797340":0,"book-toc-797423":0,"book-toc-797965":0,"book-toc-798243":0,"book-toc-798305":0,"book-toc-798601":0,"book-toc-798695":0,"book-toc-798700":0,"book-toc-801897":0,"book-toc-802011":0,"book-toc-802065":0,"book-toc-803321":0,"book-toc-806321":0,"book-toc-806409":0,"book-toc-806543":0,"book-toc-807834":0,"book-toc-808140":0,"book-toc-808197":0,"book-toc-808230":0,"book-toc-808265":0,"book-toc-808341":0,"book-toc-808476":0,"book-toc-808762":0,"book-toc-808887":0,"book-toc-810143":0,"book-toc-810152":0,"book-toc-810347":0,"book-toc-810762":0,"book-toc-810882":0,"book-toc-810895":0,"book-toc-811002":0,"book-toc-811052":0,"book-toc-811831":0,"book-toc-811840":0,"book-toc-811855":0,"book-toc-811894":0,"book-toc-812355":0,"book-toc-812360":0,"book-toc-812422":0,"book-toc-812553":0,"book-toc-812640":0,"book-toc-813079":0,"book-toc-813093":0,"book-toc-813231":0,"book-toc-813234":0,"book-toc-813491":0,"book-toc-813503":0,"book-toc-813516":0,"book-toc-813529":0,"book-toc-813541":0,"book-toc-813554":0,"book-toc-813566":0,"book-toc-813578":0,"book-toc-813620":0,"book-toc-813635":0,"book-toc-814433":0,"book-toc-814538":0,"book-toc-814674":0,"book-toc-814677":0,"book-toc-814678":0,"book-toc-814679":0,"book-toc-814681":0,"book-toc-815105":0,"book-toc-815159":0,"book-toc-815209":0,"book-toc-815346":0,"book-toc-816063":0,"book-toc-816151":0,"book-toc-816810":0,"book-toc-816916":0,"book-toc-816922":0,"book-toc-820074":0,"book-toc-820096":0,"book-toc-820119":0,"book-toc-820221":0,"book-toc-820527":0,"book-toc-820886":0,"book-toc-820890":0,"book-toc-820896":0,"book-toc-821311":0,"book-toc-821540":0,"book-toc-821728":0,"book-toc-821729":0,"book-toc-821737":0,"book-toc-821837":0,"book-toc-821849":0,"book-toc-822032":0,"book-toc-823446":0,"book-toc-827737":0,"book-toc-828677":0,"book-toc-828688":0,"book-toc-829084":0,"book-toc-829369":0,"book-toc-829643":0,"book-toc-829670":0,"book-toc-829714":0,"book-toc-830200":0,"book-toc-830224":0,"book-toc-830248":0,"book-toc-830253":0,"book-toc-830272":0,"book-toc-830313":0,"book-toc-830339":0,"book-toc-831130":0,"book-toc-831162":0,"book-toc-831294":0,"book-toc-831295":0,"book-toc-831525":0,"book-toc-831651":0,"book-toc-831918":0,"book-toc-832622":0,"book-toc-832635":0,"book-toc-832745":0,"book-toc-832747":0,"book-toc-832895":0,"book-toc-833062":0,"book-toc-833063":0,"book-toc-833066":0,"book-toc-833085":0,"book-toc-834869":0,"book-toc-834887":0,"book-toc-836435":0,"book-toc-836462":0,"book-toc-836568":0,"book-toc-836964":0,"book-toc-836965":0,"book-toc-836966":0,"book-toc-836967":0,"book-toc-836969":0,"book-toc-837066":0,"book-toc-837083":0,"book-toc-837110":0,"book-toc-837180":0,"book-toc-837237":0,"book-toc-840088":0,"book-toc-840210":0,"book-toc-840696":0,"book-toc-840711":0,"book-toc-840751":0,"book-toc-840772":0,"book-toc-840836":0,"book-toc-840838":0,"book-toc-840839":0,"book-toc-840845":0,"book-toc-840941":0,"book-toc-840943":0,"book-toc-840945":0,"book-toc-841269":0,"book-toc-841398":0,"book-toc-841399":0,"book-toc-841456":0,"book-toc-841608":0,"book-toc-842009":0,"book-toc-842079":0,"book-toc-842081":0,"book-toc-842086":0,"book-toc-842206":0,"book-toc-842224":0,"book-toc-842226":0,"book-toc-842227":0,"book-toc-842228":0,"book-toc-842229":0,"book-toc-842230":0,"book-toc-842812":0,"book-toc-843287":0,"book-toc-843295":0,"book-toc-843300":0,"book-toc-843308":0,"book-toc-843321":0,"book-toc-843364":0,"book-toc-843372":0,"book-toc-843377":0,"book-toc-843386":0,"book-toc-843399":0,"book-toc-843439":0,"book-toc-843497":0,"book-toc-843653":0,"book-toc-843990":0,"book-toc-844189":0,"book-toc-844198":0,"book-toc-844621":0,"book-toc-844622":0,"book-toc-844623":0,"book-toc-844624":0,"book-toc-844625":0,"book-toc-844626":0,"book-toc-844627":0,"book-toc-844628":0,"book-toc-844629":0,"book-toc-844630":0,"book-toc-844631":0,"book-toc-844632":0,"book-toc-844633":0,"book-toc-844634":0,"book-toc-844635":0,"book-toc-844642":0,"book-toc-844643":0,"book-toc-844644":0,"book-toc-844645":0,"book-toc-844646":0,"book-toc-844647":0,"book-toc-844648":0,"book-toc-844649":0,"book-toc-844650":0,"book-toc-844651":0,"book-toc-844652":0,"book-toc-844653":0,"book-toc-844654":0,"book-toc-844655":0,"book-toc-844656":0,"book-toc-844675":0,"book-toc-844676":0,"book-toc-844687":0,"book-toc-844702":0,"book-toc-844712":0,"book-toc-844757":0,"book-toc-844904":0,"book-toc-845177":0,"book-toc-846736":0,"book-toc-848565":0,"book-toc-848765":0,"book-toc-848917":0,"book-toc-849086":0,"book-toc-849103":0,"book-toc-849110":0,"book-toc-849122":0,"book-toc-849135":0,"book-toc-849142":0,"book-toc-849159":0,"book-toc-849167":0,"book-toc-849177":0,"book-toc-849185":0,"book-toc-849227":0,"book-toc-849335":0,"book-toc-849344":0,"book-toc-849385":0,"book-toc-849616":0,"book-toc-849762":0,"book-toc-849763":0,"book-toc-849786":0}}},"gss":{"key":"017112334782586706075:axbmndd0alq"},"jcarousel":{"ajaxPath":"\/en-us\/jcarousel\/ajax\/views"},"quote_nest":"2","translations_available":{"en":"\/en-us\/articles\/api-without-secrets-introduction-to-vulkan-part-2","zh-chs":"\/zh-cn\/articles\/api-without-secrets-introduction-to-vulkan-part-2"},"node_language":"en","intel_i18n":{"language_node":"en"},"language":{"language":"en","name":"English","native":"English","direction":"0","enabled":"1","plurals":"0","formula":"","domain":"","prefix":"en-us","weight":"-10","javascript":"","provider":"locale-url"},"better_exposed_filters":{"views":{"article_related_links":{"displays":{"block":{"filters":[]}}}}},"googleanalytics":{"trackOutbound":1,"trackMailto":1,"trackDownload":1,"trackDownloadExtensions":"7z|aac|arc|arj|asf|asx|avi|bin|bz2|csv|doc|exe|flv|gif|gz|gzip|hqx|jar|jpe?g|js|mp(2|3|4|e?g)|mov(ie)?|msi|msp|pdf|phps|pkg|png|ppt|pptx|qtm?|ra(m|r)?|sea|sit|tar|tgz|torrent|txt|wav|wma|wmv|wpd|xls|xml|z|zip","trackDomainMode":1}});</script>
      <!--[if lt IE 9]>
    <script src="/sites/all/themes/zen/js/html5-respond.js"></script>
    <![endif]-->
      <meta name="microsoft" content="notranslateclasses header slider-processed comments-wrapper page-top-second-footer page-footer admin-menu-processed">
<style>:is([id*='google_ads_iframe'],[id*='taboola-'],.taboolaHeight,.taboola-placeholder,#top-ad,#credential_picker_container,#credentials-picker-container,#credential_picker_iframe,[id*='google-one-tap-iframe'],#google-one-tap-popup-container,.google-one-tap__module,.google-one-tap-modal-div,#amp_floatingAdDiv,#ez-content-blocker-container) {display:none!important;min-height:0!important;height:0!important;}</style></head>
<body class="html not-front not-logged-in no-sidebars page-node page-node- page-node-623623 node-type-article theme-zero i18n-en section-articles has-inpage-navigation path-articles-api-without-secrets-introduction-to-vulkan-part-2" style="overflow: visible;"><!-- BEGIN WAYBACK TOOLBAR INSERT -->
<script>__wm.rw(0);</script>
<div id="wm-ipp-base" lang="en" style="display: block; direction: ltr; height: 67px;" toolbar-mode="auto">
</div><div id="wm-ipp-print">The Wayback Machine - 
https://web.archive.org/web/20200503051336/https://software.intel.com/
en-us/articles/api-without-secrets-introduction-to-vulkan-part-2</div>
<script type="text/javascript">//<![CDATA[
__wm.bt(750,27,25,2,"web","https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2","20200503051336",1996,"https://web-static.archive.org/_static/",["https://web-static.archive.org/_static/css/banner-styles.css?v=p7PEIJWi","https://web-static.archive.org/_static/css/iconochive.css?v=3PDvdIFv"], false);
  __wm.rw(1);
//]]></script>
<!-- END WAYBACK TOOLBAR INSERT -->
 
<!-- Google Tag Manager -->
<noscript><iframe src="//web.archive.org/web/20200503051336if_/https://www.googletagmanager.com/ns.html?id=GTM-PZRG3F" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<script type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0];var j=d.createElement(s);var dl=l!='dataLayer'?'&l='+l:'';j.src='//web.archive.org/web/20200503051336/https://www.googletagmanager.com/gtm.js?id='+i+dl;j.type='text/javascript';j.async=true;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-PZRG3F');</script>
<!-- End Google Tag Manager -->
<script type="text/javascript">
/*<![CDATA[*/
  //configure tms
  var wapLocalCode = 'us-en'; //dynamically set per localized site, see mapping table for values
  var wapSection = "ssg-intel"; //section, specific for each site
  //load tms
  (function() {
    var host = (window.document.location.protocol == 'http:') ? "https://web.archive.org/web/20200503051336/https://www.intel.com" : "https://web.archive.org/web/20200503051336/https://www.intel.com";
    var url = host+"/content/dam/www/global/wap/wap-ssg-intel.js"; //wap file url
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;  po.src = url;
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
/*]]>*/
</script>

  <p id="skip-link">
    <a href="#main-menu" class="element-invisible element-focusable">Jump to navigation</a>
  </p>

<div id="page-wrapper" class="intel_filter_syntaxhighlighter-processed">
  <header class="header notranslate " id="header" role="banner">
    <div class="intel-blue-bar clearfix">
              <span id="header-logo-container" data-wap_type="navheader">
          <a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us" title="Home" rel="home" class="header__logo" id="logo" data-wap_type="navheader"><img src="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/logo.png" alt="Home" class="header__logo-image">

            <div class="logo-left">
              <span class="logo-img"></span>
            </div>
            <span class="logo-text"> Developer Zone</span>
          </a>
        </span>
      
        <div id="block-idz-user-login-idz-user-login" class="block block-idz-user-login first odd">

      
  <ul class="language-switcher-locale-url js-processed">
<li class="en active"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2" class="language-link active active icon-zz_000005_global" xml:lang="en" title="API without Secrets: Introduction to Vulkan* Part 2: Swap Chain">English</a><ul id="languagechooser" data-wap_type="languagechooser"><li class="zh-hans first"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/zh-cn/articles/api-without-secrets-introduction-to-vulkan-part-2" class="language-link" xml:lang="zh-hans" title="没有任何秘密的 API： Vulkan* 简介第 2 部分： 交换链">简体中文</a></li><li class="en active"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2" class="language-link active active icon-zz_000005_global" xml:lang="en" title="API without Secrets: Introduction to Vulkan* Part 2: Swap Chain">English</a><ul id="languagechooser" data-wap_type="languagechooser"></ul></li><li class="es"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/es-es/articles/api-without-secrets-introduction-to-vulkan-part-2" class="language-link" xml:lang="es">Español</a></li><li class="pt-br"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/pt-br/articles/api-without-secrets-introduction-to-vulkan-part-2" class="language-link" xml:lang="pt-br">Português</a></li><li class="ru last"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/ru-ru/articles/api-without-secrets-introduction-to-vulkan-part-2" class="language-link" xml:lang="ru">Русский</a></li></ul></li>



</ul><div id="header-user-display" class="user-display js-processed">
      <div class="login">
      <ul class="user-login-dropdown"><li class="first"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/user/login?destination=node/623623" class="login-link icon-user">Sign in</a></li><ul class="user-login-dropdown-inside"><li><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/user/login?destination=node/623623" class="login-link icon-user">Sign in</a></li><li><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/registration?lang=en-us" class="register-link">Signup</a></li></ul></ul>          </div>
  </div>
<div class="header-support" id="header-support" data-wap_type="navheader"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/support" class="icon-zz_000005_question">Support</a></div>
</div>
<div id="block-idz-search-idz-search-block" class="block block-idz-search last even">

      
  <form action="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/search/site/language/en" method="get" id="idz-search-block-form" accept-charset="UTF-8" target="_top">
  <div class="form-wrapper" id="idz_search_search_form">
        <ul id="search-dropdown-options" class="dropdown-menu">
      <li class="disabled"><a href="javascript:void(0)">Site to search:</a></li>
      <li class="divider"></li>
      <li><a class="active" href="javascript:void(0)" data-value="idz">Intel® DZ</a></li>
      <li><a href="javascript:void(0)" data-value="intel">Intel.com</a></li>
    </ul>
    <input title="Search our content library..." placeholder="Search our content library..." class="form-text" type="text" id="edit-search-keyword" name="query" size="15" maxlength="128">
    <button class="form-submit dropdown-toggle" type="submit" id="edit-submit" value="Search"></button>
  </div>
</form>
<form action="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/search/site/language/en" method="get" id="idz-search-block-form-mobile" accept-charset="UTF-8" target="_top">
  <div class="form-wrapper" id="idz_search_search_form_mobile">
    <span class="search-icon-mobile"></span>
    <input title="Search our content library..." type="search" id="edit-submit" placeholder="Search our content library..." name="query" size="15" maxlength="128">
  </div>
</form>
</div>

    </div>
  </header>
        <div id="menu-navigation" data-wap_type="navheader" class="slider-processed">

        <nav class="navigation notranslate">
          <div class="page-title-sec">
                          <span class="page__title zonetitle">Game Dev</span>
                                                      <h4 class="page__title title">Documentation</h4>
                                    </div>
          <a class="menu-icon" href="#"><i><span></span></i></a>
          <div class="menu-container" style="display: none; height: auto; overflow: hidden visible;">
            <div class="menu-container-wrapper">
              <div class="menu-containerInner">
                <ul class="menu js-processed"><hr><li class="menu__item is-leaf first leaf"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/gamedev" class="menu__link menu-node-unpublished">Home</a><hr></li>
<li class="menu__item is-expanded expanded"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us" class="menu__link">Samples &amp; Guides</a><ul class="menu js-processed"><hr><li class="menu__item is-leaf first leaf"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/gamedev/library?value=20780" class="menu__link">Code Samples</a><hr></li>
<li class="menu__item is-leaf leaf"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/gamedev/documentation" class="menu__link menu-node-unpublished">Documentation</a><hr></li>
<li class="menu__item is-leaf last leaf"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/gamedev/recent-updates" class="menu__link menu-node-unpublished menu-node-unpublished">Recent Updates</a><hr></li>
</ul><hr></li>
<li class="menu__item is-leaf leaf"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/gamedev/library" class="menu__link">Library</a><hr></li>
<li class="menu__item is-leaf leaf"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/gamedev/tools" class="menu__link menu-node-unpublished menu-node-unpublished menu-node-unpublished">Tools </a><hr></li>
<li class="menu__item is-expanded expanded"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us" class="menu__link">Training</a><ul class="menu js-processed"><hr><li class="menu__item is-leaf first leaf"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/gpa/training" class="menu__link">Intel® GPA</a><hr></li>
<li class="menu__item is-leaf leaf"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/gdc2019" class="menu__link">GDC Tech Sessions</a><hr></li>
<li class="menu__item is-leaf leaf"><a href="https://web.archive.org/web/20200503051336/https://www.twitch.tv/IntelGameDev" target="_blank" class="menu__link">Twitch.tv</a><hr></li>
<li class="menu__item is-leaf last leaf"><a href="https://web.archive.org/web/20200503051336/https://www.youtube.com/playlist?list=PLg-UKERBljNwax4IX90MW4UvwP8rNd1Dk" target="_blank" class="menu__link">YouTube* Channel</a><hr></li>
</ul><hr></li>
<li class="menu__item is-expanded expanded"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us" class="menu__link">Certify &amp; Market Your Game</a><ul class="menu js-processed"><hr><li class="menu__item is-leaf first leaf"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/gamedev/get-started" class="menu__link menu-node-unpublished menu-node-unpublished">Get Started</a><hr></li>
<li class="menu__item is-leaf leaf"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/gamedev/get-certified" class="menu__link">Get Certified</a><hr></li>
<li class="menu__item is-leaf leaf"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/gamedev/boost" class="menu__link">Get a Boost</a><hr></li>
<li class="menu__item is-leaf leaf"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/gamedev/join" class="menu__link">Join Our Program</a><hr></li>
<li class="menu__item is-leaf last leaf"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/gamedev/boost/success-stories" class="menu__link">Success Stories</a><hr></li>
</ul><hr></li>
<li class="menu__item is-expanded last expanded"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us" class="menu__link menu-node-unpublished menu-node-unpublished">Partners</a><ul class="menu js-processed"><hr><li class="menu__item is-leaf first leaf"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/gamedev/partners/microsoft" class="menu__link">Microsoft</a><hr></li>
<li class="menu__item is-leaf leaf"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/gamedev/partners/unity" class="menu__link menu-node-unpublished">Unity*</a><hr></li>
<li class="menu__item is-leaf leaf"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/gamedev/partners/unreal" class="menu__link menu-node-unpublished">Unreal* </a><hr></li>
<li class="menu__item is-leaf last leaf"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/gamedev/partners" class="menu__link">View All</a><hr></li>
</ul><hr></li>
</ul><h2 class="block__title CORE-2649"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us">All Developer Programs</a></h2>
              </div>
              <div class="mobile-top-menu clearfix">
                    <div id="block-idz-user-login-idz-user-login" class="block block-idz-user-login first odd">

      
  <ul class="language-switcher-locale-url js-processed">
<li class="en active"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2" class="language-link active active icon-zz_000005_global" xml:lang="en" title="API without Secrets: Introduction to Vulkan* Part 2: Swap Chain">English</a><ul><li class="zh-hans first"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/zh-cn/articles/api-without-secrets-introduction-to-vulkan-part-2" class="language-link" xml:lang="zh-hans" title="没有任何秘密的 API： Vulkan* 简介第 2 部分： 交换链">简体中文</a></li><li class="en active"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2" class="language-link active active icon-zz_000005_global" xml:lang="en" title="API without Secrets: Introduction to Vulkan* Part 2: Swap Chain">English</a><ul></ul></li><li class="es"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/es-es/articles/api-without-secrets-introduction-to-vulkan-part-2" class="language-link" xml:lang="es">Español</a></li><li class="pt-br"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/pt-br/articles/api-without-secrets-introduction-to-vulkan-part-2" class="language-link" xml:lang="pt-br">Português</a></li><li class="ru last"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/ru-ru/articles/api-without-secrets-introduction-to-vulkan-part-2" class="language-link" xml:lang="ru">Русский</a></li></ul></li>



</ul><div id="header-user-display" class="user-display js-processed">
      <div class="login">
      <ul class="user-login-dropdown"><li class="first"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/user/login?destination=node/623623" class="login-link icon-user">Sign in</a></li><ul class="user-login-dropdown-inside"><li><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/user/login?destination=node/623623" class="login-link icon-user">Sign in</a></li><li><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/registration?lang=en-us" class="register-link">Signup</a></li></ul></ul>          </div>
  </div>
<div class="header-support" id="header-support" data-wap_type="navheader"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/support" class="icon-zz_000005_question">Support</a></div>
</div>
<div id="block-idz-search-idz-search-block" class="block block-idz-search last even">

      
  <form action="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/search/site/language/en" method="get" id="idz-search-block-form" accept-charset="UTF-8" target="_top">
  <div class="form-wrapper" id="idz_search_search_form">
        <ul id="search-dropdown-options" class="dropdown-menu">
      <li class="disabled"><a href="javascript:void(0)">Site to search:</a></li>
      <li class="divider"></li>
      <li><a class="active" href="javascript:void(0)" data-value="idz">Intel® DZ</a></li>
      <li><a href="javascript:void(0)" data-value="intel">Intel.com</a></li>
    </ul>
    <input title="Search our content library..." placeholder="Search our content library..." class="form-text" type="text" id="edit-search-keyword" name="query" size="15" maxlength="128">
    <button class="form-submit dropdown-toggle" type="submit" id="edit-submit" value="Search"></button>
  </div>
</form>
<form action="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/search/site/language/en" method="get" id="idz-search-block-form-mobile" accept-charset="UTF-8" target="_top">
  <div class="form-wrapper" id="idz_search_search_form_mobile">
    <span class="search-icon-mobile"></span>
    <input title="Search our content library..." type="search" id="edit-submit" placeholder="Search our content library..." name="query" size="15" maxlength="128">
  </div>
</form>
</div>
              </div>
            </div>
          </div>
        </nav>
        <div id="navigation-right">
            <div id="block-idz-zero-idz-zero-share-widget-block" class="block block-idz-zero first last odd">

      
  <div class="show_all_widget notranslate">
  <div class="item-list"><ul id="wap-social" data-wap_type="socialshare"><li class="facebook first"><a href="https://web.archive.org/web/20200503051336/https://www.facebook.com/sharer/sharer.php?u=https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2" class="icon-logo-facebook" target="_blank" data-wap_ref="facebook">Share</a></li>
<li class="twitter"><a href="https://web.archive.org/web/20200503051336/https://twitter.com/intent/tweet?text=API+without+Secrets%3A+Introduction+to+Vulkan%2A+Part+2%3A+Swap+Chain%3A&amp;url=https%3A%2F%2Fsoftware.intel.com%2Fen-us%2Farticles%2Fapi-without-secrets-introduction-to-vulkan-part-2&amp;hashtags=IntelSoftware" class="icon-logo-twitter-bird" target="_blank" data-wap_ref="twitter" data-hashtags="IntelSoftware" data-text="API without Secrets: Introduction to Vulkan* Part 2: Swap Chain:" data-url="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2">Tweet</a></li>
<li class="google"><a href="https://web.archive.org/web/20200503051336/https://plus.google.com/share?url=https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2" class="icon-logo-gplus" target="_blank" data-wap_ref="twitter">Share</a></li>
<li class="send last"><a href="https://web.archive.org/web/20200503051336/mailto:/?subject=API%20without%20Secrets:%20Introduction%20to%20Vulkan*%20Part%202:%20Swap%20Chain&amp;body=https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2" class="icon-email" target="_self" data-wap_ref="send">Send</a></li>
</ul></div></div>
<div class="showsharewidget notranslate">
  <span class="share_label icon-zz_000005_share">
    Share  </span>
</div>


</div>
        </div>
      </div>
        <div id="main">

      <div id="content" class="column" role="main">
                <a id="main-content"></a>

                                        


<article class="node-623623 node node-article view-mode-full clearfix" about="/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2" typeof="sioc:Item foaf:Document">

      <header>
            <h1 class="node__title node-title" id="page-title">API without Secrets: Introduction to Vulkan* Part 2: Swap Chain</h1>
                  <span property="dc:title" content="API without Secrets: Introduction to Vulkan* Part 2: Swap Chain" class="rdf-meta element-hidden"></span><span property="sioc:num_replies" content="2" datatype="xsd:integer" class="rdf-meta element-hidden"></span>        <div class="submitted-and-translation clearfix">
                          <p class="submitted ctHidden" data-hj-masked="">
                                <span property="dc:date dc:created" content="2016-04-05T09:57:03-07:00" datatype="xsd:dateTime" rel="sioc:has_creator">By <a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/user/1183993" title="View user profile" class="username" data-hj-masked="">Pawel L.</a>, published on April 5, 2016</span>              </p>
            
                      </div>

          </header>
  
  <div id="inpage-navigation" style="margin-top: 302px; height: 661px;"><h4 id="inpage-nav-contents">CONTENTS</h4><ul class="inpage-nav"><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-1"><span class="word_arrow">Tutorial</span> 2: Swap Chain – Integrating Vulkan with the OS</a></li><li class="parent haschildren"><a class="jumplink" href="#inpage-nav-2"><span class="word_arrow">Asking</span> for a Swap Chain Extension</a><ul class="inpage-nav list-h3" style=""><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-2-1"><span class="word_arrow">Checking</span> Whether an Instance Extension Is Supported</a></li><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-2-2"><span class="word_arrow">Enabling</span> an Instance-Level Extension</a></li><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-2-3"><span class="word_arrow">Creating</span> a Presentation Surface</a></li><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-2-4"><span class="word_arrow">Checking</span> Whether a Device Extension is Supported</a></li><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-2-5"><span class="word_arrow">Checking</span> Whether Presentation to a Given Surface Is Supported</a></li><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-2-6"><span class="word_arrow">Creating</span> a Device with a Swap Chain Extension Enabled</a></li></ul></li><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-3"><span class="word_arrow">Creating</span> a Semaphore</a></li><li class="parent haschildren"><a class="jumplink" href="#inpage-nav-4"><span class="word_arrow">Creating</span> a Swap Chain</a><ul class="inpage-nav list-h3" style=""><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-4-1"><span class="word_arrow">Acquiring</span> Surface Capabilities</a></li><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-4-2"><span class="word_arrow">Acquiring</span> Supported Surface Formats</a></li></ul></li><li class="parent haschildren"><a class="jumplink" href="#inpage-nav-5"><span class="word_arrow">Acquiring</span> Supported Present Modes</a><ul class="inpage-nav list-h3" style=""><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-5-1"><span class="word_arrow">Selecting</span> the Number of Swap Chain Images</a></li><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-5-2"><span class="word_arrow">Selecting</span> a Format for Swap Chain Images</a></li><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-5-3"><span class="word_arrow">Selecting</span> the Size of the Swap Chain Images</a></li><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-5-4"><span class="word_arrow">Selecting</span> Swap Chain Usage Flags</a></li><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-5-5"><span class="word_arrow">Selecting</span> Pre-Transformations</a></li><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-5-6"><span class="word_arrow">Selecting</span> Presentation Mode</a></li><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-5-7"><span class="word_arrow">Creating</span> a Swap Chain</a></li></ul></li><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-6"><span class="word_arrow">Image</span> Presentation</a></li><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-7"><span class="word_arrow">Checking</span> What Images Were Created in a Swap Chain</a></li><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-8"><span class="word_arrow">Recreating</span> a Swap Chain</a></li><li class="parent haschildren"><a class="jumplink" href="#inpage-nav-9"><span class="word_arrow">Quick</span> Dive into Command Buffers</a><ul class="inpage-nav list-h3" style=""><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-9-1"><span class="word_arrow">Creating</span> Command Buffer Memory Pool</a></li><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-9-2"><span class="word_arrow">Allocating</span> Command Buffers</a></li><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-9-3"><span class="word_arrow">Recording</span> Command Buffers</a></li><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-9-4"><span class="word_arrow">Image</span> Layouts and Layout Transitions</a></li><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-9-5"><span class="word_arrow">Recording</span> Command Buffers</a></li></ul></li><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-10"><span class="word_arrow">Tutorial</span> 2 Execution</a></li><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-11"><span class="word_arrow">Cleaning</span> Up</a></li><li class="parent nochildren"><a class="jumplink" href="#inpage-nav-12"><span class="word_arrow">Conclusion</span></a></li></ul></div><div class="field field-name-body field-type-text-with-summary field-label-hidden"><div class="field-items"><div class="field-item even" property="content:encoded"><p><a class="button-highlight" href="https://web.archive.org/web/20200503051336/https://github.com/GameTechDev/IntroductionToVulkan" target="_blank" rel="nofollow">Download</a></p><p><a class="button-white-border" href="https://web.archive.org/web/20200503051336/https://software.intel.com/sites/default/files/managed/99/41/api-without-secrets-introduction-to-vulkan-part-2.pdf">View PDF</a> [1 MB]</p><p><strong>Back to: <a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-1">Part 1 The Beginning</a><br>
	Next up: <a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-3">Part 3 First Triangle</a></strong></p><hr><h2>Tutorial 2: Swap Chain – Integrating Vulkan with the OS<a class="inpage-nav-anchor" id="inpage-nav-1"></a></h2><p>Welcome
 to the second Vulkan tutorial. In the first tutorial, I discussed basic
 Vulkan setup: function loading, instance creation, choosing a physical 
device and queues, and logical device creation. I'm sure you now want to
 draw something! Unfortunately we must wait until the next part. Why? 
Because if we draw something we'll want to see it. Similar to OpenGL*, 
we must integrate the Vulkan pipeline with the application and API that 
the OS provides. However, with Vulkan, this task unfortunately isn't 
simple and obvious. And as with all other thin APIs, it is done this way
 on purpose—for the sake of high performance and flexibility.</p><p>So 
how do you integrate Vulkan with the application's window? What are the 
differences compared to OpenGL? In OpenGL (on Microsoft Windows*) we 
acquire Device Context that is associated with the application's window.
 Using it we then have to define “how” to present images on the screen, 
“what” the format is of the application's window we will be drawing on, 
and what capabilities it should support. This is done through the pixel 
format. Most of the time we create a 32-bit color surface with a 24-bit 
depth buffer and a support for double buffering (this way we can draw 
something to a “hidden” back buffer, and after we're finished we can 
present it on the screen—swap front and back buffers). Only after these 
preparations can we create a Rendering Context and activate it. In 
OpenGL, all the rendering is directed to the default, back buffer.</p><p>In
 Vulkan there is no default frame buffer. We can create an application 
that displays nothing at all. This is a valid approach. But if we want 
to display something we can create a set of buffers to which we can 
render. These buffers along with their properties, similar to Direct3D*,
 are called a swap chain. A swap chain can contain many images. To 
display any of them we don't “swap” them—as the name suggests—but we 
present them, which means that we give them back to a presentation 
engine. So in OpenGL we first have to define the surface format and 
associate it with a window (at least on Windows) and after that we 
create Rendering Context. In Vulkan, we first create an instance, a 
device, and then we create a swap chain. But, what's interesting is that
 there will be situations where we will have to destroy this swap chain 
and recreate it. In the middle of a working application. From scratch!</p><h2>Asking for a Swap Chain Extension<a class="inpage-nav-anchor" id="inpage-nav-2"></a></h2><p>In
 Vulkan, a swap chain is an extension. Why? Isn't it obvious we want to 
display an image on the screen in our application's window?</p><p>Well, 
it's not so obvious. Vulkan can be used for many different purposes, 
including performing mathematical operations, boosting physics 
calculations, and processing a video stream. The results of these 
actions may not necessarily be displayed on a typical monitor, which is 
why the core API is OS-agnostic, similar to OpenGL.</p><p>If you want to
 create a game and display rendered images on a monitor, you can (and 
should) use a swap chain. But here is the second reason why a swap chain
 is an extension. Every OS displays images in a different way. The&nbsp;
 surface on which you can render may be implemented differently, can 
have a different format, and can be differently represented in the 
OS—there is no one universal way to do it. So in Vulkan a swap chain 
must also depend on the OS your application is written for.</p><p>These 
are the reasons a swap chain in Vulkan is treated as an extension: it 
provides render targets (buffers or images like FBOs in OpenGL) that 
integrates with OS specific code. It's something that core Vulkan (which
 is platform independent) can't do. So if swap chain creation and usage 
is an extension, we have to ask for the extension during both instance 
and device creation. The ability to create and use a swap chain requires
 us to enable extensions at two levels (at least on most operating 
systems, with Windows and Linux* among them). This means that we have to
 go back to the first tutorial and change it to request the proper 
swap-chain-related extensions. If a given instance and device doesn't 
support these extensions, the instance and/or device creation will fail.
 There are of course other ways through which we can display an image, 
like acquiring the pointer to a buffer's (texture's) memory (mapping it)
 and copying data from it to the OS-acquired window's surface pointer. 
This process is out of scope of this tutorial (though not really that 
hard). But fortunately it seems that swap chain extensions will be 
similar to OpenGL's core extensions: they will be something that's not 
in the core spec and that's not required to be implemented but they also
 are something that every hardware vendor will implement anyway. I think
 all hardware vendors would like to show that they support Vulkan and 
that it gives impressive performance boost in games which are displayed 
on screen. And, what backs this theory, swap chain extensions are 
integrated into the main, “core” vulkan.h header.</p><p>In the case of 
swap-chain support, there are actually three extensions involved: two 
from an instance level and one from a device level. These extensions 
logically separate different functionalities. The first is the <strong><em>VK_KHR_surface</em></strong>
 extension defined at the instance level. It describes a “surface” 
object, which is a logical representation of an application's window. 
This extension allows us to check different parameters (that is, 
&nbsp;capabilities, supported formats, size) of a surface and to query 
whether the given physical device supports a swap chain (more precisely,
 whether the given queue family supports presenting an image to a given 
surface). This is useful information because we don't want to choose a 
physical device and try to create a logical device from it only to find 
out that it doesn't support swap chains. This extension also defines 
methods to destroy any such surface.</p><p>The second instance-level extension is OS-dependent: in the Windows OS family it is called <strong><em>VK_KHR_win32_surface</em></strong> and in Linux it is called <strong><em>VK_KHR_xlib_surface</em></strong> or <strong><em>VK_KHR_xcb_surface</em></strong>.
 This extension allows us to create a surface that represents the 
application's window in a given OS (and uses OS-specific parameters).</p><h3>Checking Whether an Instance Extension Is Supported<a class="inpage-nav-anchor" id="inpage-nav-2-1"></a></h3><p>Before
 we can enable the two instance-level extensions, we need to check 
whether they are available or supported. We are talking about instance 
extensions and we haven't created any instance yet. To determine whether
 our Vulkan instance supports these extensions, we use a global-level 
function called <strong>vkEnumerateInstanceExtensionProperties()</strong>.
 It enumerates all available instance general extensions, if its first 
parameter is null, or instance layer extensions (it seems that layers 
can also have extensions), if we set the first parameter to the name of 
any given layer. We aren't interested in layers so we leave the first 
parameter set to null. Again we call this function twice. For the first 
call, we want to acquire the total number of supported extensions so we 
leave the third argument nulled. Next we prepare storage for all these 
extensions and we call this function once again with the third parameter
 pointing to the allocated storage.</p><div id="highlighter_917168" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="plain">uint32_t extensions_count = 0;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( (vkEnumerateInstanceExtensionProperties( nullptr, &amp;extensions_count, nullptr ) != VK_SUCCESS) ||</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">(extensions_count == 0) ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Error occurred during instance extensions enumeration!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="plain">std::vector&lt;VkExtensionProperties&gt; available_extensions( extensions_count );</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( vkEnumerateInstanceExtensionProperties( nullptr, &amp;extensions_count, &amp;available_extensions[0] ) != VK_SUCCESS ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Error occurred during instance extensions enumeration!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>14</code></td><td class="content"><code class="plain">std::vector&lt;</code><code class="keyword bold">const</code> <code class="color1 bold">char</code><code class="plain">*&gt; extensions = {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>15</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_KHR_SURFACE_EXTENSION_NAME,</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>16</code></td><td class="content"><code class="preprocessor">#if defined(VK_USE_PLATFORM_WIN32_KHR)</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>17</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_KHR_WIN32_SURFACE_EXTENSION_NAME</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>18</code></td><td class="content"><code class="preprocessor">#elif defined(VK_USE_PLATFORM_XCB_KHR)</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>19</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_KHR_XCB_SURFACE_EXTENSION_NAME</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>20</code></td><td class="content"><code class="preprocessor">#elif defined(VK_USE_PLATFORM_XLIB_KHR)</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>21</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_KHR_XLIB_SURFACE_EXTENSION_NAME</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>22</code></td><td class="content"><code class="preprocessor">#endif</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>23</code></td><td class="content"><code class="plain">};</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>24</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>25</code></td><td class="content"><code class="keyword bold">for</code><code class="plain">( </code><code class="color1 bold">size_t</code> <code class="plain">i = 0; i &lt; extensions.size(); ++i ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>26</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">( !CheckExtensionAvailability( extensions[i], available_extensions ) ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>27</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Could not find instance extension named \""</code> <code class="plain">&lt;&lt; extensions[i] &lt;&lt; </code><code class="string">"\"!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>28</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>29</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>30</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div><p><strong>1.</strong><em> Tutorial02.cpp, function CreateInstance()</em></p><p>We can prepare a place for a smaller amount of extensions, but then <strong>vkEnumerateInstanceExtensionProperties()</strong> will return VK_INCOMPLETE to let us know we didn't acquire all the extensions.</p><p>Our
 array is now filled with all available (supported) instance-level 
extensions. Each element of our allocated space contains the name of the
 extension and its version. The second parameter probably won't be used 
too often, but it may be useful to check whether the hardware supports 
the given version of the extension. For example, we might be 
&nbsp;interested in some specific extension, and we downloaded an SDK 
for it that contains a set of header files. Each header file has its own
 version corresponding to the value returned by this query. If the 
hardware our application is executed on supports an older version of the
 extension (not the one we downloaded the SDK for) it may not support 
all the functions we are using from this specific extension. So 
sometimes it may be useful to also verify the version, but for a swap 
chain it doesn't matter—at least for now.</p><p>We can now search 
through all of the returned extensions and see whether the list contains
 the extensions we are looking for. Here I'm using two convenient 
definitions named VK_KHR_SURFACE_EXTENSION_NAME and 
VK_KHR_????_SURFACE_EXTENSION_NAME. They are defined inside a Vulkan 
header file and contain the names of the extensions so we don't have to 
copy or remember them. We just can use the definitions in our code, and 
if we make a mistake the compiler will tell us. I hope all extensions 
will come with a similar definition.</p><p>With the second definition 
comes a small trap. These two mentioned defines are placed in a vulkan.h
 header file. But isn't the second define specific for a given OS and 
isn't vulkan.h header OS independent? Both questions are true and quite 
valid. The vulkan.h file is OS-independent and it contains the 
definitions of OS-specific extensions. But these are enclosed inside 
#ifdef … #endif preprocessor directives. If we want to “enable” them we 
need to add a proper preprocessor directive somewhere in our project. 
For a Windows system, we need to add a VK_USE_PLATFORM_WIN32_KHR string.
 On Linux, we need to add VK_USE_PLATFORM_XCB_KHR or 
VK_USE_PLATFORM_XLIB_KHR depending on whether we want to use the X11 or 
XCB libraries. In the provided example project, these definitions are 
added by default through the CMakeLists.txt file.</p><p>But back to our 
source code. What does the CheckExtensionAvailability() function do? It 
loops over all available extensions and compares their names with the 
name of the provided extension. If a match is found, it just returns 
true.</p><div id="highlighter_792841" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>1</code></td><td class="content"><code class="keyword bold">for</code><code class="plain">( </code><code class="color1 bold">size_t</code> <code class="plain">i = 0; i &lt; available_extensions.size(); ++i ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>2</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">( </code><code class="functions bold">strcmp</code><code class="plain">( available_extensions[i].extensionName, extension_name ) == 0 ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>3</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>4</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>5</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>6</code></td><td class="content"><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div></div></div><p><strong>2.</strong><em>Tutorial02.cpp, function CheckExtensionAvailability()</em></p><h3>Enabling an Instance-Level Extension<a class="inpage-nav-anchor" id="inpage-nav-2-2"></a></h3><p>Let's
 say we have verified that both extensions are supported. Instance-level
 extensions are requested (enabled) during instance creation—we create 
an instance with a list of extensions that should be enabled. Here's the
 code responsible for doing it:</p><div id="highlighter_427516" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="plain">VkApplicationInfo application_info = {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_STRUCTURE_TYPE_APPLICATION_INFO,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">// VkStructureType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sType</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">nullptr,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pNext</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="string">"API without Secrets: Introduction to Vulkan"</code><code class="plain">,&nbsp; </code><code class="comments">// const char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pApplicationName</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_MAKE_VERSION( 1,
 0, 0 
),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 applicationVersion</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="string">"Vulkan Tutorial by Intel"</code><code class="plain">,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">// const char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pEngineName</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_MAKE_VERSION( 1,
 0, 0 
),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 engineVersion</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_API_VERSION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 apiVersion</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="plain">};</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="plain">VkInstanceCreateInfo instance_create_info = {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">// VkStructureType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sType</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">nullptr,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pNext</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>14</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// VkInstanceCreateFlags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>15</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">&amp;application_info,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const VkApplicationInfo&nbsp;&nbsp; *pApplicationInfo</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>16</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 enabledLayerCount</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>17</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">nullptr,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const char * const&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppEnabledLayerNames</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>18</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">static_cast</code><code class="plain">&lt;uint32_t&gt;(extensions.size()),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">//
 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 enabledExtensionCount</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>19</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">&amp;extensions[0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const char * const&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppEnabledExtensionNames</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>20</code></td><td class="content"><code class="plain">};</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>21</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>22</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( vkCreateInstance( &amp;instance_create_info, nullptr, &amp;Vulkan.Instance ) != VK_SUCCESS ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>23</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Could not create Vulkan instance!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>24</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>25</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>26</code></td><td class="content"><code class="keyword bold">return</code> <code class="keyword bold">true</code><code class="plain">;</code></td></tr></tbody></table></div></div></div><p><strong>3.</strong><em>Tutorial02.cpp, function CreateInstance()</em></p><p>This code is similar to the <strong>CreateInstance()</strong>
 function in the Tutorial01.cpp file. To request instance-level 
extensions we have to prepare an array with the names of all extensions 
we want to enable. Here I have used a standard vector with “const char*”
 elements and mentioned extension names in forms of defines.</p><p>In 
Tutorial 1 we declared zero extensions and placed a nullptr for the 
address of an array in a VkInstanceCreateInfo structure. This time we 
must provide an address of the first element of an array filled with the
 names of the requested extensions. And we must also specify how many 
elements the array contains (that's why I chose a vector: if I add or 
remove extensions in future tutorials, the vector's size will also 
change accordingly). Next we call the <strong>vkCreateInstance()</strong>
 function. If it doesn't return VK_SUCCESS it means that (in the case of
 this tutorial) extensions are not supported. If it does return 
successfully, we can load instance-level functions as previously, but 
this time also with some additional, extension-specific functions.</p><p>With
 these extensions come additional functions. And, as it is an 
instance-level extension, we must add them to our set of instance-level 
functions (so they will also be loaded at a proper moment and with a 
proper function). In this case we must add the following functions into a
 ListOfFunctions.inl wrapped into a VK_INSTANCE_LEVEL_FUNCTION() macro 
like this:</p><div id="highlighter_540329" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="comments">// From extensions</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="preprocessor">#if defined(USE_SWAPCHAIN_EXTENSIONS)</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="plain">VK_INSTANCE_LEVEL_FUNCTION( vkDestroySurfaceKHR )</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="plain">VK_INSTANCE_LEVEL_FUNCTION( vkGetPhysicalDeviceSurfaceSupportKHR )</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="plain">VK_INSTANCE_LEVEL_FUNCTION( vkGetPhysicalDeviceSurfaceCapabilitiesKHR )</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="plain">VK_INSTANCE_LEVEL_FUNCTION( vkGetPhysicalDeviceSurfaceFormatsKHR )</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content"><code class="plain">VK_INSTANCE_LEVEL_FUNCTION( vkGetPhysicalDeviceSurfacePresentModesKHR )</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="preprocessor">#if defined(VK_USE_PLATFORM_WIN32_KHR)</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="plain">VK_INSTANCE_LEVEL_FUNCTION( vkCreateWin32SurfaceKHR )</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="preprocessor">#elif defined(VK_USE_PLATFORM_XCB_KHR)</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="plain">VK_INSTANCE_LEVEL_FUNCTION( vkCreateXcbSurfaceKHR )</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="preprocessor">#elif defined(VK_USE_PLATFORM_XLIB_KHR)</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content"><code class="plain">VK_INSTANCE_LEVEL_FUNCTION( vkCreateXlibSurfaceKHR )</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>14</code></td><td class="content"><code class="preprocessor">#endif</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>15</code></td><td class="content"><code class="preprocessor">#endif</code></td></tr></tbody></table></div></div></div><p><strong>4.</strong><em>ListOfFunctions.inl</em></p><p>One
 more thing: I've wrapped all these swap-chain-related functions inside 
another #ifdef … #endif pair, which requires a USE_SWAPCHAIN_EXTENSIONS 
preprocessor directive to be defined. I've done this so Tutorial 1 would
 properly work. Without it, our first application (as it uses the same 
header files) would try to load all these functions. But we don't enable
 swap chain extensions in the first tutorial, so this operation would 
fail and the application would close without fully initializing Vulkan. 
If a given extension isn't enabled, functions from it may not be 
available.</p><h3>Creating a Presentation Surface<a class="inpage-nav-anchor" id="inpage-nav-2-3"></a></h3><p>We
 have created a Vulkan instance with two extensions enabled. We have 
loaded instance-level functions from a core Vulkan spec and from enabled
 extensions (this is done automatically thanks to our macros). To create
 a surface, we write code similar to the following:</p><div id="highlighter_813379" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="preprocessor">#if defined(VK_USE_PLATFORM_WIN32_KHR)</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="plain">VkWin32SurfaceCreateInfoKHR surface_create_info = {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR,&nbsp; </code><code class="comments">// VkStructureType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sType</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">nullptr,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const 
void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 *pNext</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// VkWin32SurfaceCreateFlagsKHR&nbsp;&nbsp;&nbsp;&nbsp; flags</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">Window.Instance,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
HINSTANCE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 hinstance</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">Window.Handle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
HWND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 hwnd</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="plain">};</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">(
 vkCreateWin32SurfaceKHR( Vulkan.Instance, &amp;surface_create_info, 
nullptr, &amp;Vulkan.PresentationSurface ) == VK_SUCCESS ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>14</code></td><td class="content"><code class="preprocessor">#elif defined(VK_USE_PLATFORM_XCB_KHR)</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>15</code></td><td class="content"><code class="plain">VkXcbSurfaceCreateInfoKHR surface_create_info = {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>16</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR,&nbsp;&nbsp;&nbsp; </code><code class="comments">// VkStructureType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sType</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>17</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">nullptr,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const 
void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 *pNext</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>18</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// VkXcbSurfaceCreateFlagsKHR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>19</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">Window.Connection,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// xcb_connection_t*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connection</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>20</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">Window.Handle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
xcb_window_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 window</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>21</code></td><td class="content"><code class="plain">};</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>22</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>23</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( vkCreateXcbSurfaceKHR( Vulkan.Instance, &amp;surface_create_info, nullptr, &amp;Vulkan.PresentationSurface ) == VK_SUCCESS ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>24</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>25</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>26</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>27</code></td><td class="content"><code class="preprocessor">#elif defined(VK_USE_PLATFORM_XLIB_KHR)</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>28</code></td><td class="content"><code class="plain">VkXlibSurfaceCreateInfoKHR surface_create_info = {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>29</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR,&nbsp;&nbsp; </code><code class="comments">// VkStructureType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sType</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>30</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">nullptr,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const 
void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 *pNext</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>31</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// VkXlibSurfaceCreateFlagsKHR&nbsp;&nbsp;&nbsp; flags</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>32</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">Window.DisplayPtr,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
Display&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 *dpy</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>33</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">Window.Handle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
Window&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 window</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>34</code></td><td class="content"><code class="plain">};</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>35</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">(
 vkCreateXlibSurfaceKHR( Vulkan.Instance, &amp;surface_create_info, 
nullptr, &amp;Vulkan.PresentationSurface ) == VK_SUCCESS ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>36</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>37</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>38</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>39</code></td><td class="content"><code class="preprocessor">#endif</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>40</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>41</code></td><td class="content"><code class="plain">std::cout &lt;&lt; </code><code class="string">"Could not create presentation surface!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>42</code></td><td class="content"><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div></div></div><p><strong>5.</strong><em>Tutorial02.cpp, function CreatePresentationSurface()</em></p><p>To create a presentation surface, we call the <strong>vkCreate????SurfaceKHR()</strong>
 function, which accepts Vulkan Instance (with enabled surface 
extensions), a pointer to a OS-specific structure, a pointer to optional
 memory allocation handling functions, and a pointer to a variable in 
which a handle to a created surface will be stored.</p><p>This OS-specific structure is called <strong>Vk????SurfaceCreateInfoKHR</strong> and it contains the following fields:</p><ul><li>sType – Standard type of structure that here should be equal to <strong>VK_STRUCTURE_TYPE_????_SURFACE_CREATE_INFO_KHR</strong> (where ???? can be WIN32, XCB, XLIB, or other)</li><li>pNext – Standard pointer to some other structure</li><li>flags – Parameter reserved for future use</li><li>hinstance/connection/dpy – First OS-specific parameter</li><li>hwnd/window – Handle to our application's window (also OS specific)</li></ul><h3>Checking Whether a Device Extension is Supported<a class="inpage-nav-anchor" id="inpage-nav-2-4"></a></h3><p>We
 have created an instance and a surface. The next step is to create a 
logical device. But we want to create a device that supports a swap 
chain. So we also need to check whether a given physical device supports
 a swap chain extension, a device-level extension. This extension is 
called <strong><em>VK_KHR_swapchain</em></strong>, and it defines the actual support, implementation, and usage of a swap chain.</p><p>To
 check what extensions given physical device supports we must create 
code similar to the code prepared for instance-level extensions. This 
time we just use the <strong>vkEnumerateDeviceExtensionProperties()</strong>
 function. It behaves identically to the function querying instance 
extensions. The only difference is that it takes an additional physical 
device handle in the first argument. The code for this may look similar 
to the example below. It is a part of the 
CheckPhysicalDeviceProperties() function in our example source code.</p><div id="highlighter_447282" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="plain">uint32_t extensions_count = 0;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( (vkEnumerateDeviceExtensionProperties( physical_device, nullptr, &amp;extensions_count, nullptr ) != VK_SUCCESS) ||</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">(extensions_count == 0) ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Error occurred during physical device "</code> <code class="plain">&lt;&lt; physical_device &lt;&lt; </code><code class="string">" extensions enumeration!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="plain">std::vector&lt;VkExtensionProperties&gt; available_extensions( extensions_count );</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">(
 vkEnumerateDeviceExtensionProperties( physical_device, nullptr, 
&amp;extensions_count, &amp;available_extensions[0] ) != VK_SUCCESS ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Error occurred during physical device "</code> <code class="plain">&lt;&lt; physical_device &lt;&lt; </code><code class="string">" extensions enumeration!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>14</code></td><td class="content"><code class="plain">std::vector&lt;</code><code class="keyword bold">const</code> <code class="color1 bold">char</code><code class="plain">*&gt; device_extensions = {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>15</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_KHR_SWAPCHAIN_EXTENSION_NAME</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>16</code></td><td class="content"><code class="plain">};</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>17</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>18</code></td><td class="content"><code class="keyword bold">for</code><code class="plain">( </code><code class="color1 bold">size_t</code> <code class="plain">i = 0; i &lt; device_extensions.size(); ++i ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>19</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">( !CheckExtensionAvailability( device_extensions[i], available_extensions ) ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>20</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Physical device "</code> <code class="plain">&lt;&lt; physical_device &lt;&lt; </code><code class="string">" doesn't support extension named \""</code> <code class="plain">&lt;&lt; device_extensions[i] &lt;&lt; </code><code class="string">"\"!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>21</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>22</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>23</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div><p><strong>6.</strong><em>Tutorial02.cpp, function CheckPhysicalDeviceProperties()</em></p><p>We
 first ask for the number of all extensions available on a given 
physical device. Next we get their names and look for the device-level 
swap-chain extension. If there is none there is no point in further 
checking the device's properties, features, and queue families' 
properties as a given device doesn't support swap chain at all.</p><h3>Checking Whether Presentation to a Given Surface Is Supported<a class="inpage-nav-anchor" id="inpage-nav-2-5"></a></h3><p>Let's
 go back to the CreateDevice() function. After creating an instance, in 
the first tutorial we looped through all available physical devices and 
queried their properties. Based on these properties we selected which 
device we want to use and which queue families we want to request. This 
query is done in a loop over all available physical devices. Now that we
 want to use swap chain I have to modify my 
CheckPhysicalDeviceProperties() function that is called inside a 
mentioned loop from CreateDevice() function like this:</p><div id="highlighter_383398" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>1</code></td><td class="content"><code class="plain">uint32_t selected_graphics_queue_family_index = UINT32_MAX;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>2</code></td><td class="content"><code class="plain">uint32_t selected_present_queue_family_index = UINT32_MAX;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>3</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>4</code></td><td class="content"><code class="keyword bold">for</code><code class="plain">( uint32_t i = 0; i &lt; num_devices; ++i ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>5</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">(
 CheckPhysicalDeviceProperties( physical_devices[i], 
selected_graphics_queue_family_index, 
selected_present_queue_family_index ) ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>6</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Vulkan.PhysicalDevice = physical_devices[i];</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>7</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>8</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div><p><strong>7.</strong><em>Tutorial02.cpp, function CreateDevice()</em></p><p>The
 only change is that I've added another variable that will contain an 
index of a queue family that supports a swap chain (more precisely image
 presentation). Unfortunately, just checking whether swap extension is 
supported is not enough because presentation support is a queue family 
property. A physical device may support swap chains, but that doesn't 
mean that all its queue families also support it. And do we really need 
another queue or queue family for displaying images? Can't we just use 
graphics queue that we'd selected in the first tutorial? Most of the 
time one queue family will probably be enough for our needs. This means 
that the selected queue family will support both graphics operations and
 a presentation. But, unfortunately, it is also possible that there will
 be devices that won't support graphics and presenting within a single 
queue family. In Vulkan we have to be flexible and prepared for any 
situation.</p><p><strong>vkGetPhysicalDeviceSurfaceSupportKHR()</strong>
 function is used to check whether a given queue family from a given 
physical device supports a swap chain or, to be more precise, whether it
 supports presenting images to a given surface. That's why we needed to 
create a surface earlier.</p><p>So assume we have already checked 
whether a given physical device exposes a swap-chain extension and that 
we have already queried for a number of different queue families 
supported by a given physical device. We have also requested the 
properties of all queue families. Now we can check whether a given queue
 family supports presentation to our surface (window).</p><div id="highlighter_192713" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="plain">uint32_t graphics_queue_family_index = UINT32_MAX;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="plain">uint32_t present_queue_family_index = UINT32_MAX;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="keyword bold">for</code><code class="plain">( uint32_t i = 0; i &lt; queue_families_count; ++i ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">vkGetPhysicalDeviceSurfaceSupportKHR( physical_device, i, Vulkan.PresentationSurface, &amp;queue_present_support[i] );</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">( (queue_family_properties[i].queueCount &gt; 0) &amp;&amp;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">(queue_family_properties[i].queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Select first queue that supports graphics</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">( graphics_queue_family_index == UINT32_MAX ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">graphics_queue_family_index = i;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>14</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// If there is queue that supports both graphics and present - prefer it</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>15</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">( queue_present_support[i] ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>16</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">selected_graphics_queue_family_index = i;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>17</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">selected_present_queue_family_index = i;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>18</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>19</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>20</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>21</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>22</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>23</code></td><td class="content"><code class="comments">// We don't have queue that supports both graphics and present so we have to use separate queues</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>24</code></td><td class="content"><code class="keyword bold">for</code><code class="plain">( uint32_t i = 0; i &lt; queue_families_count; ++i ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>25</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">( queue_present_support[i] ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>26</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">present_queue_family_index = i;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>27</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>28</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>29</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>30</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>31</code></td><td class="content"><code class="comments">// If this device doesn't support queues with graphics and present capabilities don't use it</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>32</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( (graphics_queue_family_index == UINT32_MAX) ||</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>33</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">(present_queue_family_index == UINT32_MAX) ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>34</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Could not find queue family with required properties on physical device "</code> <code class="plain">&lt;&lt; physical_device &lt;&lt; </code><code class="string">"!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>35</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>36</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>37</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>38</code></td><td class="content"><code class="plain">selected_graphics_queue_family_index = graphics_queue_family_index;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>39</code></td><td class="content"><code class="plain">selected_present_queue_family_index = present_queue_family_index;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>40</code></td><td class="content"><code class="keyword bold">return</code> <code class="keyword bold">true</code><code class="plain">;</code></td></tr></tbody></table></div></div></div><p><strong>8.</strong><em>Tutorial02.cpp, function CheckPhysicalDeviceProperties()</em></p><p>Here
 we are iterating over all available queue families. In each loop 
iteration, we are calling a function responsible for checking whether a 
given queue family supports presentation. <strong>vkGetPhysicalDeviceSurfaceSupportKHR()</strong>
 function requires us to provide a physical device handle, the queue 
family index we want to check, and the surface handle we want to render 
into (present an image). If support is available, VK_TRUE will be stored
 at a given address; otherwise VK_FALSE is stored.</p><p>Now we have the
 properties of all available queue families. We know which queue family 
supports graphics operations and which supports presentation. In our 
tutorial example I prefer families that support both. If I find one I 
store the family index and exit immediately from 
CheckPhysicalDeviceProperties() function. If there is no such queue 
family I use the first queue family that supports graphics and a first 
family that supports presenting. Only then can I leave the function with
 a “success” return code.</p><p>A more advanced scenario may search 
through all available devices and try to find one with a queue family 
that supports both graphics and presentation operations. But I can also 
imagine situations when there will be no single device that supports 
both. Then we are forced to use one device for graphics calculations 
(maybe like the old “graphics accelerator”) and another device for 
presenting results on the screen (connected with the “accelerator” and a
 monitor). Unfortunately in such case we must use “general” Vulkan 
functions from the Vulkan Runtime or we need to store device‑level 
functions for each used device (each device may have a different 
implementation of Vulkan functions). But, hopefully, such situations 
will be uncommon.</p><h3>Creating a Device with a Swap Chain Extension Enabled<a class="inpage-nav-anchor" id="inpage-nav-2-6"></a></h3><p>Now
 we can return to the CreateDevice() function. We have found the 
physical device that supports both graphics and presenting but not 
necessarily in a single queue family. We now need to create a logical 
device.</p><div id="highlighter_631400" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="plain">std::vector&lt;VkDeviceQueueCreateInfo&gt; queue_create_infos;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="plain">std::vector&lt;</code><code class="color1 bold">float</code><code class="plain">&gt; queue_priorities = { 1.0f };</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="plain">queue_create_infos.push_back( {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">// VkStructureType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sType</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">nullptr,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pNext</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// VkDeviceQueueCreateFlags&nbsp;&nbsp;&nbsp;&nbsp; flags</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">selected_graphics_queue_family_index,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">//
 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 queueFamilyIndex</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">static_cast</code><code class="plain">&lt;uint32_t&gt;(queue_priorities.size()),&nbsp;&nbsp; </code><code class="comments">//
 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 queueCount</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">&amp;queue_priorities[0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pQueuePriorities</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="plain">} );</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( selected_graphics_queue_family_index != selected_present_queue_family_index ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>14</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">queue_create_infos.push_back( {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>15</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">// VkStructureType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sType</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>16</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">nullptr,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pNext</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>17</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// VkDeviceQueueCreateFlags&nbsp;&nbsp;&nbsp;&nbsp; flags</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>18</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">selected_present_queue_family_index,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">//
 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 queueFamilyIndex</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>19</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">static_cast</code><code class="plain">&lt;uint32_t&gt;(queue_priorities.size()), </code><code class="comments">//
 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 queueCount</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>20</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">&amp;queue_priorities[0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pQueuePriorities</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>21</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">} );</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>22</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>23</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>24</code></td><td class="content"><code class="plain">std::vector&lt;</code><code class="keyword bold">const</code> <code class="color1 bold">char</code><code class="plain">*&gt; extensions = {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>25</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_KHR_SWAPCHAIN_EXTENSION_NAME</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>26</code></td><td class="content"><code class="plain">};</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>27</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>28</code></td><td class="content"><code class="plain">VkDeviceCreateInfo device_create_info = {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>29</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">//
 
VkStructureType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 sType</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>30</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">nullptr,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const 
void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 *pNext</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>31</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// VkDeviceCreateFlags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>32</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">static_cast</code><code class="plain">&lt;uint32_t&gt;(queue_create_infos.size()), </code><code class="comments">//
 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 queueCreateInfoCount</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>33</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">&amp;queue_create_infos[0],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const VkDeviceQueueCreateInfo&nbsp;&nbsp;&nbsp;&nbsp; *pQueueCreateInfos</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>34</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 enabledLayerCount</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>35</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">nullptr,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const char * 
const&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 *ppEnabledLayerNames</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>36</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">static_cast</code><code class="plain">&lt;uint32_t&gt;(extensions.size()),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">//
 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 enabledExtensionCount</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>37</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">&amp;extensions[0],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const char * 
const&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 *ppEnabledExtensionNames</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>38</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">nullptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const VkPhysicalDeviceFeatures&nbsp;&nbsp;&nbsp; *pEnabledFeatures</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>39</code></td><td class="content"><code class="plain">};</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>40</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>41</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( vkCreateDevice( Vulkan.PhysicalDevice, &amp;device_create_info, nullptr, &amp;Vulkan.Device ) != VK_SUCCESS ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>42</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Could not create Vulkan device!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>43</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>44</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>45</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>46</code></td><td class="content"><code class="plain">Vulkan.GraphicsQueueFamilyIndex = selected_graphics_queue_family_index;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>47</code></td><td class="content"><code class="plain">Vulkan.PresentQueueFamilyIndex = selected_present_queue_family_index;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>48</code></td><td class="content"><code class="keyword bold">return</code> <code class="keyword bold">true</code><code class="plain">;</code></td></tr></tbody></table></div></div></div><p><strong>9.</strong><em>Tutorial02.cpp, function CreateDevice()</em></p><p>As
 before, we need to fill a variable of VkDeviceCreateInfo type. To do 
this, we need to declare the queue families and how many queues each we 
want to enable. We do this through a pointer to a separate array with 
VkDeviceQueueCreateInfo elements. Here I declare a vector and I add one 
element, which defines one queue from the queue family that supports 
graphics operations. We use a vector because if graphics and presenting 
aren't supported by a single family, we will need to define two separate
 families. If a single family supports both we just define one member 
and declare that only one family is needed. If the indices of graphics 
and presentation families are different we need to declare additional 
members for our vector with VkDeviceQueueCreateInfo elements. In this 
case the VkDeviceCreateInfo structure must provide info about two 
different families. That's why a vector once again comes in handy (with 
its size() member function).</p><p>But we are not finished with device 
creation yet. We have to ask for the third extension related to a swap 
chain—a device-level “<strong><em>VK_KHR_swapchain</em></strong>” extension. As mentioned earlier, this extensions defines the actual support, implementation, and usage of a swap chain.</p><p>To
 ask for this extension, similarly at an instance level, we define an 
array (or a vector) which contains all the names of device-level 
extensions we want to enable. We provide an address of a first element 
of this array and the number of extensions we want to use. This 
extension also contains a definition of its name in a form of a #define 
VK_KHR_SWAPCHAIN_EXTENSION_NAME. We can use it inside our array 
(vector), and we don't have to worry about any typos.</p><p>This third 
extension introduces additional functions used to actually create, 
destroy, or in general manage swap chains. Before we can use them, we of
 course need to load pointers to these functions. They are from the 
device level so we will place them in a ListOfFunctions.inl file using 
VK_DEVICE_LEVEL_FUNCTION() macro:</p><div id="highlighter_863040" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>1</code></td><td class="content"><code class="comments">// From extensions</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>2</code></td><td class="content"><code class="preprocessor">#if defined(USE_SWAPCHAIN_EXTENSIONS)</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>3</code></td><td class="content"><code class="plain">VK_DEVICE_LEVEL_FUNCTION( vkCreateSwapchainKHR )</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>4</code></td><td class="content"><code class="plain">VK_DEVICE_LEVEL_FUNCTION( vkDestroySwapchainKHR )</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>5</code></td><td class="content"><code class="plain">VK_DEVICE_LEVEL_FUNCTION( vkGetSwapchainImagesKHR )</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>6</code></td><td class="content"><code class="plain">VK_DEVICE_LEVEL_FUNCTION( vkAcquireNextImageKHR )</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>7</code></td><td class="content"><code class="plain">VK_DEVICE_LEVEL_FUNCTION( vkQueuePresentKHR )</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>8</code></td><td class="content"><code class="preprocessor">#endif</code></td></tr></tbody></table></div></div></div><p><strong>10.</strong><em> ListOfFunctions.inl</em></p><p>You
 can once again see that I'm checking whether a USE_SWAPCHAIN_EXTENSIONS
 preprocessor directive is defined. I define it only in projects that 
enable swap-chain extensions.</p><p>Now that we have created a logical 
devices we need to receive handles of a graphics queue and (if separate)
 presentation queue. I'm using two separate queue variables for 
convenience, but they both may contain the same handle.</p><p>After loading the device-level functions we can read requested queue handles. Here's the code for it:</p><div id="highlighter_347509" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>1</code></td><td class="content"><code class="plain">vkGetDeviceQueue( Vulkan.Device, Vulkan.GraphicsQueueFamilyIndex, 0, &amp;Vulkan.GraphicsQueue );</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>2</code></td><td class="content"><code class="plain">vkGetDeviceQueue( Vulkan.Device, Vulkan.PresentQueueFamilyIndex, 0, &amp;Vulkan.PresentQueue );</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>3</code></td><td class="content"><code class="keyword bold">return</code> <code class="keyword bold">true</code><code class="plain">;</code></td></tr></tbody></table></div></div></div><p><strong>11.</strong><em>Tutorial02.cpp, function GetDeviceQueue()</em></p><h2>Creating a Semaphore<a class="inpage-nav-anchor" id="inpage-nav-3"></a></h2><p>One
 last step before we can move to swap chain creation and usage is to 
create a semaphore. Semaphores are objects used for queue 
synchronization. They may be signaled or unsignaled. One queue may 
signal a semaphore (change its state from unsignaled to signaled) when 
some operations are finished, and another queue may wait on the 
semaphore until it becomes signaled. After that, the queue resumes 
performing operations submitted through command buffers.</p><div id="highlighter_396536" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="plain">VkSemaphoreCreateInfo semaphore_create_info = {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">// VkStructureType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sType</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">nullptr,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const void*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pNext</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// VkSemaphoreCreateFlags&nbsp;&nbsp; flags</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="plain">};</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">(
 (vkCreateSemaphore( Vulkan.Device, &amp;semaphore_create_info, nullptr,
 &amp;Vulkan.ImageAvailableSemaphore ) != VK_SUCCESS) ||</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">(vkCreateSemaphore( Vulkan.Device,
 &amp;semaphore_create_info, nullptr, 
&amp;Vulkan.RenderingFinishedSemaphore ) != VK_SUCCESS) ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Could not create semaphores!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content"><code class="keyword bold">return</code> <code class="keyword bold">true</code><code class="plain">;</code></td></tr></tbody></table></div></div></div><p><strong>12.</strong><em>Tutorial02.cpp, function CreateSemaphores()</em></p><p>To create a semaphore we call the <strong>vkCreateSemaphore()</strong> function. It requires us to provide create information with three fields:</p><ul><li>sType – Standard structure type that must be set to VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO in this example.</li><li>pNext – Standard parameter reserved for future use.</li><li>flags – Another parameter that is reserved for future use and must equal zero.</li></ul><p>Semaphores are used during drawing (or during presentation if we want to be more precise). I will describe the details later.</p><h2>Creating a Swap Chain<a class="inpage-nav-anchor" id="inpage-nav-4"></a></h2><p>We
 have enabled support for a swap chain, but before we can render 
anything on screen we must first create a swap chain from which we can 
acquire images on which we can render (or to which we can copy anything 
if we have rendered something into another image).</p><p>To create a swap chain, we call the <strong>vkCreateSwapchainKHR()</strong>
 function. It requires us to provide an address of a variable of type 
VkSwapchainCreateInfoKHR, which informs the driver about the properties 
of a swap chain that is being created. To fill this structure with the 
proper values, we must determine what is possible on a given hardware 
and platform. To do this we query the platform's or window's properties 
about the availability of and compatibility with several different 
features, that is, supported image formats or present modes (how images 
are presented on screen). So before we can create a swap chain we must 
check what is possible with a given platform and how we can create a 
swap chain.</p><h3>Acquiring Surface Capabilities<a class="inpage-nav-anchor" id="inpage-nav-4-1"></a></h3><p>First we must query for surface capabilities. To do this, we call the &nbsp;<strong>vkGetPhysicalDeviceSurfaceCapabilitiesKHR()</strong> function like this:</p><div id="highlighter_395923" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>1</code></td><td class="content"><code class="plain">VkSurfaceCapabilitiesKHR surface_capabilities;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>2</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">(
 vkGetPhysicalDeviceSurfaceCapabilitiesKHR( Vulkan.PhysicalDevice, 
Vulkan.PresentationSurface, &amp;surface_capabilities ) != VK_SUCCESS ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>3</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Could not check presentation surface capabilities!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>4</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>5</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div><p><strong>13.</strong><em>Tutorial02.cpp, function CreateSwapChain()</em></p><p>Acquired
 capabilities contain important information about ranges (limits) that 
are supported by the swap chain, that is, minimal and maximal number of 
images, minimal and maximal dimensions of images, or supported 
transforms (some platforms may require transformations applied to images
 before these images may be presented).</p><h3>Acquiring Supported Surface Formats<a class="inpage-nav-anchor" id="inpage-nav-4-2"></a></h3><p>Next,
 we need to query for supported surface formats. Not all platforms are 
compatible with typical image formats like non-linear 32-bit RGBA. Some 
platforms don't have any preferences, but other may only support a small
 range of formats. We can only select one of the available formats for a
 swap chain or its creation will fail.</p><p>To query for surface formats, we must call the <strong>vkGetPhysicalDeviceSurfaceFormatsKHR()</strong>
 function. We can do it, as usual, twice: the first time to acquire the 
number of supported formats and a second time to acquire supported 
formats in an array prepared for this purpose. It can be done like this:</p><div id="highlighter_694436" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="plain">uint32_t formats_count;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">(
 (vkGetPhysicalDeviceSurfaceFormatsKHR( Vulkan.PhysicalDevice, 
Vulkan.PresentationSurface, &amp;formats_count, nullptr ) != VK_SUCCESS)
 ||</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">(formats_count == 0) ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Error occurred during presentation surface formats enumeration!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="plain">std::vector&lt;VkSurfaceFormatKHR&gt; surface_formats( formats_count );</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">(
 vkGetPhysicalDeviceSurfaceFormatsKHR( Vulkan.PhysicalDevice, 
Vulkan.PresentationSurface, &amp;formats_count, &amp;surface_formats[0] )
 != VK_SUCCESS ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Error occurred during presentation surface formats enumeration!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div><p><strong>14.</strong><em>Tutorial02.cpp, function CreateSwapChain()</em></p><h2><a name="_Toc445674473" id="_Toc445674473"></a>Acquiring Supported Present Modes<a class="inpage-nav-anchor" id="inpage-nav-5"></a></h2><p>We
 should also ask for the available present modes, which tell us how 
images are presented (displayed) on the screen. The present mode defines
 whether an application will wait for v-sync or whether it will display 
an image immediately when it is available (which will probably lead to 
image tearing). I describe different present modes later.</p><p>To query for present modes that are supported on a given platform, we call the <strong>vkGetPhysicalDeviceSurfacePresentModesKHR()</strong> function. We can create code similar to this one:</p><div id="highlighter_159358" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="plain">uint32_t present_modes_count;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">(
 (vkGetPhysicalDeviceSurfacePresentModesKHR( Vulkan.PhysicalDevice, 
Vulkan.PresentationSurface, &amp;present_modes_count, nullptr ) != 
VK_SUCCESS) ||</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">(present_modes_count == 0) ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Error occurred during presentation surface present modes enumeration!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="plain">std::vector&lt;VkPresentModeKHR&gt; present_modes( present_modes_count );</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">(
 vkGetPhysicalDeviceSurfacePresentModesKHR( Vulkan.PhysicalDevice, 
Vulkan.PresentationSurface, &amp;present_modes_count, 
&amp;present_modes[0] ) != VK_SUCCESS ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Error occurred during presentation surface present modes enumeration!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div><p><strong>15.</strong><em>Tutorial02.cpp, function CreateSwapChain()</em></p><p>We now have acquired all the data that will help us prepare the proper values for a swap chain creation.</p><h3>Selecting the Number of Swap Chain Images<a class="inpage-nav-anchor" id="inpage-nav-5-1"></a></h3><p>A
 swap chain consists of multiple images. Several images (typically more 
than one) are required for the presentation engine to work properly, 
that is, one image is presented on the screen, another image waits in a 
queue for the next v-sync, and a third image is available for the 
application to render into.</p><p>An application may request more 
images. If it wants to use multiple images at once it may do so, for 
example, when encoding a video stream where every fourth image is a key 
frame and the application needs it to prepare the remaining three 
frames. Such usage will determine the number of images that will be 
automatically created in a swap chain: how many images the application 
requires at once for processing and how many images the presentation 
engine requires to function properly.</p><p>But we must ensure that the 
requested number of swap chain images is not smaller than the minimal 
required number of images and not greater than the maximal supported 
number of images (if there is such a limitation). And too many images 
will require much more memory. On the other hand, too small a number of 
images may cause stalls in the application (more about this later).</p><p>The
 number of images that are required for a swap chain to work properly 
and for an application to be able to render to is defined in the surface
 capabilities. Here is some code that checks whether the number of 
images is between the allowable min and max values:</p><div id="highlighter_398714" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>1</code></td><td class="content"><code class="comments">// Set of images defined in a swap chain may not always be available for application to render to:</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>2</code></td><td class="content"><code class="comments">// One may be displayed and one may wait in a queue to be presented</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>3</code></td><td class="content"><code class="comments">// If application wants to use more images at the same time it must ask for more images</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>4</code></td><td class="content"><code class="plain">uint32_t image_count = surface_capabilities.minImageCount + 1;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>5</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( (surface_capabilities.maxImageCount &gt; 0) &amp;&amp;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>6</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">(image_count &gt; surface_capabilities.maxImageCount) ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>7</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">image_count = surface_capabilities.maxImageCount;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>8</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>9</code></td><td class="content"><code class="keyword bold">return</code> <code class="plain">image_count;</code></td></tr></tbody></table></div></div></div><p><strong>16.</strong><em>Tutorial02.cpp, function GetSwapChainNumImages()</em></p><p>The
 minImageCount value in the surface capabilities structure gives the 
required minimum number of images for the swap chain to work properly. 
Here I'm selecting one more image than is required, and I also check 
whether I'm asking for too much. One more image may be useful for triple
 buffering-like presentation mode (if it is available). In more advanced
 scenarios we would also be required to store the number of images we 
want to use at the same time (at once). Let's say we want to encode a 
mentioned video stream and we need a key frame (every forth image frame)
 and the other three images. But a swap chain doesn't allow the 
application to operate on four images at once—only on three. We need to 
know that because we can only prepare two frames from a key frame, then 
we need to release them (give them back to a presentation engine) and 
only then can we acquire the last, third, non-key frame. This will 
become clearer later.</p><h3>Selecting a Format for Swap Chain Images<a class="inpage-nav-anchor" id="inpage-nav-5-2"></a></h3><p>Choosing
 a format for the images depends on the type of processing/rendering we 
want to do, that is, if we want to blend the application window with the
 desktop contents, an alpha value may be required. We must also know 
what color space is available and if we operate on linear or sRGB 
colorspace.</p><p>Each platform may support a different number of 
format-colorspace pairs. If we want to use specific ones we must make 
sure that they are available.</p><div id="highlighter_650159" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="comments">// If the list contains only one entry with undefined format</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="comments">// it means that there are no preferred surface formats and any can be chosen</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( (surface_formats.size() == 1) &amp;&amp;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">(surface_formats[0].format == VK_FORMAT_UNDEFINED) ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">{ VK_FORMAT_R8G8B8A8_UNORM, VK_COLORSPACE_SRGB_NONLINEAR_KHR };</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="comments">// Check if list contains most widely used R8 G8 B8 A8 format</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="comments">// with nonlinear color space</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="keyword bold">for</code><code class="plain">( VkSurfaceFormatKHR &amp;surface_format : surface_formats ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">( surface_format.format == VK_FORMAT_R8G8B8A8_UNORM ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">surface_format;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>14</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>15</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>16</code></td><td class="content"><code class="comments">// Return the first format from the list</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>17</code></td><td class="content"><code class="keyword bold">return</code> <code class="plain">surface_formats[0];</code></td></tr></tbody></table></div></div></div><p><strong>17.</strong><em>Tutorial02.cpp, function GetSwapChainFormat()</em></p><p>Earlier
 we requested a supported format which was placed in an array (a vector 
in our case). If this array contains only one value with an undefined 
format, that platform doesn't have any preferences. We can use any image
 format we want.</p><p>In other cases, we can use only one of the 
available formats. Here I'm looking for any (linear or not) 32-bit RGBA 
format. If it is available I can choose it. If there is no such format I
 will use any format from the list (hoping that the first is also the 
best and contains the format with the most precision).</p><h3>Selecting the Size of the Swap Chain Images<a class="inpage-nav-anchor" id="inpage-nav-5-3"></a></h3><p>Typically
 the size of swap chain images will be identical to the window size. We 
can choose other sizes, but we must fit into image size constraints. The
 size of an image that would fit into the current application window's 
size is available in the surface capabilities structure, in 
“currentExtent” member.</p><p>One thing worth noting is that a special 
value of “-1” indicates that the application's window size will be 
determined by the swap chain size, so we can choose whatever dimension 
we want. But we must still make sure that the selected size is not 
smaller and not greater than the defined minimum and maximum 
constraints.</p><p>Selecting the swap chain size may (and probably usually will) look like this:</p><div id="highlighter_336531" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="comments">// Special value of surface extent is width == height == -1</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="comments">// If this is so we define the size by ourselves but it must fit within defined confines</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( surface_capabilities.currentExtent.width == -1 ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VkExtent2D swap_chain_extent = { 640, 480 };</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">( swap_chain_extent.width &lt; surface_capabilities.minImageExtent.width ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">swap_chain_extent.width = surface_capabilities.minImageExtent.width;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">( swap_chain_extent.height &lt; surface_capabilities.minImageExtent.height ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">swap_chain_extent.height = surface_capabilities.minImageExtent.height;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">( swap_chain_extent.width &gt; surface_capabilities.maxImageExtent.width ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">swap_chain_extent.width = surface_capabilities.maxImageExtent.width;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>14</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">( swap_chain_extent.height &gt; surface_capabilities.maxImageExtent.height ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>15</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">swap_chain_extent.height = surface_capabilities.maxImageExtent.height;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>16</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>17</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">swap_chain_extent;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>18</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>19</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>20</code></td><td class="content"><code class="comments">// Most of the cases we define size of the swap_chain images equal to current window's size</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>21</code></td><td class="content"><code class="keyword bold">return</code> <code class="plain">surface_capabilities.currentExtent;</code></td></tr></tbody></table></div></div></div><p><strong>18.</strong><em>Tutorial02.cpp, function GetSwapChainExtent()</em></p><h3>Selecting Swap Chain Usage Flags<a class="inpage-nav-anchor" id="inpage-nav-5-4"></a></h3><p>Usage
 flags define how a given image may be used in Vulkan. If we want an 
image to be sampled (used inside shaders) it must be created with 
“sampled” usage. If the image should be used as a depth render target, 
it must be created with “depth and stencil” usage. An image without 
proper usage “enabled” cannot be used for a given purpose or the results
 of such operations will be undefined.</p><p>For a swap chain we want to
 render (in most cases) into the image (use it as a render target), so 
we must specify “color attachment” usage with 
VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT enum. In Vulkan this usage is always
 available for swap chains, so we can always set it without any 
additional checking. But for any other usage we must ensure it is 
supported – we can do this through a “supportedUsageFlags” member of 
surface capabilities structure.</p><div id="highlighter_288079" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="comments">// Color attachment flag must always be supported</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="comments">// We can define other usage flags but we always need to check if they are supported</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( surface_capabilities.supportedUsageFlags &amp; VK_IMAGE_USAGE_TRANSFER_DST_BIT ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="plain">std::cout &lt;&lt; </code><code class="string">"VK_IMAGE_USAGE_TRANSFER_DST image usage is not supported by the swap chain!"</code> <code class="plain">&lt;&lt; std::endl</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">&lt;&lt; </code><code class="string">"Supported swap chain's image usages include:"</code> <code class="plain">&lt;&lt; std::endl</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">&lt;&lt;
 (surface_capabilities.supportedUsageFlags &amp; 
VK_IMAGE_USAGE_TRANSFER_SRC_BIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?
 </code><code class="string">"&nbsp;&nbsp;&nbsp; VK_IMAGE_USAGE_TRANSFER_SRC\n"</code> <code class="plain">: </code><code class="string">""</code><code class="plain">)</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">&lt;&lt;
 (surface_capabilities.supportedUsageFlags &amp; 
VK_IMAGE_USAGE_TRANSFER_DST_BIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?
 </code><code class="string">"&nbsp;&nbsp;&nbsp; VK_IMAGE_USAGE_TRANSFER_DST\n"</code> <code class="plain">: </code><code class="string">""</code><code class="plain">)</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">&lt;&lt;
 (surface_capabilities.supportedUsageFlags &amp; 
VK_IMAGE_USAGE_SAMPLED_BIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?
 </code><code class="string">"&nbsp;&nbsp;&nbsp; VK_IMAGE_USAGE_SAMPLED\n"</code> <code class="plain">: </code><code class="string">""</code><code class="plain">)</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">&lt;&lt;
 (surface_capabilities.supportedUsageFlags &amp; 
VK_IMAGE_USAGE_STORAGE_BIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?
 </code><code class="string">"&nbsp;&nbsp;&nbsp; VK_IMAGE_USAGE_STORAGE\n"</code> <code class="plain">: </code><code class="string">""</code><code class="plain">)</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">&lt;&lt;
 (surface_capabilities.supportedUsageFlags &amp; 
VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?
 </code><code class="string">"&nbsp;&nbsp;&nbsp; VK_IMAGE_USAGE_COLOR_ATTACHMENT\n"</code> <code class="plain">: </code><code class="string">""</code><code class="plain">)</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">&lt;&lt; (surface_capabilities.supportedUsageFlags &amp; VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT&nbsp; ? </code><code class="string">"&nbsp;&nbsp;&nbsp; VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT\n"</code> <code class="plain">: </code><code class="string">""</code><code class="plain">)</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>14</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">&lt;&lt;
 (surface_capabilities.supportedUsageFlags &amp; 
VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ? </code><code class="string">"&nbsp;&nbsp;&nbsp; VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT\n"</code> <code class="plain">: </code><code class="string">""</code><code class="plain">)</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>15</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">&lt;&lt;
 (surface_capabilities.supportedUsageFlags &amp; 
VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?
 </code><code class="string">"&nbsp;&nbsp;&nbsp; VK_IMAGE_USAGE_INPUT_ATTACHMENT"</code> <code class="plain">: </code><code class="string">""</code><code class="plain">)</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>16</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>17</code></td><td class="content"><code class="keyword bold">return</code> <code class="keyword bold">static_cast</code><code class="plain">&lt;VkImageUsageFlags&gt;(-1);</code></td></tr></tbody></table></div></div></div><p><strong>19.</strong><em>Tutorial02.cpp, function GetSwapChainUsageFlags()</em></p><p>In this example we define additional “transfer destination” usage which is required for image clear operation.</p><h3>Selecting Pre-Transformations<a class="inpage-nav-anchor" id="inpage-nav-5-5"></a></h3><p>On
 some platforms we may want our image to be transformed. This is usually
 the case on tablets when they are oriented in a way other than their 
default orientation. During swap chain creation we must specify what 
transformations should be applied to images prior to presenting. We can,
 of course, use only the supported transforms, which can be found in a 
“supportedTransforms” member of acquired surface capabilities.</p><p>If 
the selected pre-transform is other than the current transformation 
(also found in surface capabilities) the presentation engine will apply 
the selected transformation. On some platforms this may cause 
performance degradation (probably not noticeable but worth mentioning). 
In the sample code, I don't want any transformations but, of course, I 
must check whether it is supported. If not, I'm just using the same 
transformation that is currently used.</p><div id="highlighter_631344" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="comments">// Sometimes images must be transformed before they are presented (i.e. due to device's orienation</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="comments">// being other than default orientation)</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="comments">// If the specified transform is other than current transform, presentation engine will transform image</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="comments">// during presentation operation; this operation may hit performance on some platforms</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="comments">// Here we don't want any transformations to occur so if the identity transform is supported use it</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="comments">// otherwise just use the same transform as current transform</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( surface_capabilities.supportedTransforms &amp; VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="plain">} </code><code class="keyword bold">else</code> <code class="plain">{</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">surface_capabilities.currentTransform;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div><p><strong>20.</strong><em>Tutorial02.cpp, function GetSwapChainTransform()</em></p><h3>Selecting Presentation Mode<a class="inpage-nav-anchor" id="inpage-nav-5-6"></a></h3><p>Present
 modes determine the way images will be processed internally by the 
presentation engine and displayed on the screen. In the past, there was 
just a single buffer that was displayed all the time. If we were drawing
 anything on it the draw operations (whole process of image creation) 
were visible.</p><p>Double buffering was introduced to prevent the 
visibility of drawing operations: one image was displayed and the second
 was used to render into. During presentation, the contents of the 
second image were copied into the first image (earlier) or (later) the 
images were swapped (remember SwapBuffers() function used in OpenGL 
applications?) which means that their pointers were exchanged.</p><p>Tearing
 was another issue with displaying images, so the ability to wait for 
the vertical blank signal was introduced if we wanted to avoid it. But 
waiting introduced another problem: input lag. So double buffering was 
changed into triple buffering in which we were drawing into two back 
buffers interchangeably and during v-sync the most recent one was used 
for presentation.</p><p>This is exactly what presentation modes are for:
 how to deal with all these issues, how to present images on the screen 
and whether we want to use v-sync.</p><p>Currently there are four presentation modes:</p><ul><li>IMMEDIATE.
 Present requests are applied immediately and tearing may be observed 
(depending on the frames per second). Internally the presentation engine
 doesn't use any queue for holding swap chain images.</li></ul><p style="text-align:center"><img alt="" src="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/api-vulkan-part-2-graphic-1.jpg"></p><ul><li>FIFO.
 This mode is the most similar to OpenGL's buffer swapping with a swap 
interval set to 1. The image is displayed (replaces currently displayed 
image) only on vertical blanking periods, so no tearing should be 
visible. Internally, the presentation engine uses FIFO queue with 
“numSwapchainImages – 1” elements. Present requests are appended to the 
end of this queue. During blanking periods, the image from the beginning
 of the queue replaces the currently displayed image, which may become 
available to application. If all images are in the queue, the 
application has to wait until v-sync releases the currently displayed 
image. Only after that does it becomes available to the application and 
program may render image into it. This mode must always be available in 
all Vulkan implementations supporting swap chain extension.</li></ul><p style="text-align:center"><img alt="" src="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/api-vulkan-part-2-graphic-2.jpg"></p><ul><li>FIFO
 RELAXED. This mode is similar to FIFO, but when the image is displayed 
longer than one blanking period it may be released immediately without 
waiting for another v-sync signal (so if we are rendering frames with 
lower frequency than screen's refresh rate, tearing may be visible)<br>
		&nbsp;</li><li>MAILBOX. In my opinion, this mode is the most similar 
to the mentioned triple buffering. The image is displayed only on 
vertical blanking periods and no tearing should be visible. But 
internally, the presentation engine uses the queue with only a single 
element. One image is displayed and one waits in the queue. If 
application wants to present another image it is not appended to the end
 of the queue but replaces the one that waits. So in the queue there is 
always the most recently generated image. This behavior is available if 
there are more than two images. For two images MAILBOX mode behaves 
similarly to FIFO (as we have to wait for the displayed image to be 
released, we don't have “spare” image which can be exchanged with the 
one that waits in the queue).</li></ul><p style="text-align:center"><img alt="" src="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/api-vulkan-part-2-graphic-3.jpg"></p><p>Deciding
 on which presentation mode to use depends on the type of operations we 
want to do. If we want to decode and display movies we want all frames 
to be displayed in a proper order. So the FIFO mode is in my opinion the
 best choice. But if we are creating a game, we usually want to display 
the most recently generated frame. In this case I suggest using MAILBOX 
because there is no tearing and input lag is minimized. The most 
recently generated image is displayed and the application doesn't need 
to wait for v-sync. But to achieve this behavior, at least three images 
must be created and this mode may not always be supported.</p><p>FIFO 
mode is always available and requires at least two images but causes 
application to wait for v-sync (no matter how many swap chain images 
were requested). Immediate mode is the fastest. As I understand it, it 
also requires two images but it doesn't make application wait for 
monitor refresh rate. On the downside it may cause image tearing. The 
choice is yours but, as always, we must make sure that the chosen 
presentation mode is supported.</p><p>Earlier we queried for available 
present modes, so now we must look for the one that best suits our 
needs. Here is the code in which I'm looking for MAILBOX mode:</p><div id="highlighter_344723" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="comments">// FIFO present mode is always available</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="comments">// MAILBOX is the lowest latency V-Sync enabled mode (something like triple-buffering) so use it if available</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="keyword bold">for</code><code class="plain">( VkPresentModeKHR &amp;present_mode : present_modes ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">( present_mode == VK_PRESENT_MODE_MAILBOX_KHR ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">present_mode;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="keyword bold">for</code><code class="plain">( VkPresentModeKHR &amp;present_mode : present_modes ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">( present_mode == VK_PRESENT_MODE_FIFO_KHR ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">present_mode;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content"><code class="plain">std::cout &lt;&lt; </code><code class="string">"FIFO present mode is not supported by the swap chain!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>14</code></td><td class="content"><code class="keyword bold">return</code> <code class="keyword bold">static_cast</code><code class="plain">&lt;VkPresentModeKHR&gt;(-1);</code></td></tr></tbody></table></div></div></div><p><strong>21.</strong><em>Tutorial02.cpp, function GetSwapChainPresentMode()</em></p><h3>Creating a Swap Chain<a class="inpage-nav-anchor" id="inpage-nav-5-7"></a></h3><p>Now
 we have all the data necessary to create a swap chain. We have defined 
all the required values, and we are sure they fit into the given 
platform's constraints.</p><div id="highlighter_480684" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="plain">uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 desired_number_of_images = GetSwapChainNumImages( surface_capabilities 
);</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="plain">VkSurfaceFormatKHR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 desired_format = GetSwapChainFormat( surface_formats );</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="plain">VkExtent2D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 desired_extent = GetSwapChainExtent( surface_capabilities );</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="plain">VkImageUsageFlags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 desired_usage = GetSwapChainUsageFlags( surface_capabilities );</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="plain">VkSurfaceTransformFlagBitsKHR desired_transform = GetSwapChainTransform( surface_capabilities );</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="plain">VkPresentModeKHR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 desired_present_mode = GetSwapChainPresentMode( present_modes );</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content"><code class="plain">VkSwapchainKHR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 old_swap_chain = Vulkan.SwapChain;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( </code><code class="keyword bold">static_cast</code><code class="plain">&lt;</code><code class="color1 bold">int</code><code class="plain">&gt;(desired_usage) == -1 ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( </code><code class="keyword bold">static_cast</code><code class="plain">&lt;</code><code class="color1 bold">int</code><code class="plain">&gt;(desired_present_mode) == -1 ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>14</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>15</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>16</code></td><td class="content"><code class="plain">VkSwapchainCreateInfoKHR swap_chain_create_info = {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>17</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,&nbsp; </code><code class="comments">// VkStructureType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sType</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>18</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">nullptr,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const 
void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 *pNext</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>19</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// VkSwapchainCreateFlagsKHR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>20</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">Vulkan.PresentationSurface,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
VkSurfaceKHR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 surface</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>21</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">desired_number_of_images,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 minImageCount</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>22</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">desired_format.format,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
VkFormat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 imageFormat</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>23</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">desired_format.colorSpace,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// VkColorSpaceKHR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imageColorSpace</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>24</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">desired_extent,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
VkExtent2D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 imageExtent</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>25</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 imageArrayLayers</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>26</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">desired_usage,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// VkImageUsageFlags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imageUsage</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>27</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_SHARING_MODE_EXCLUSIVE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
VkSharingMode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 imageSharingMode</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>28</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 queueFamilyIndexCount</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>29</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">nullptr,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pQueueFamilyIndices</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>30</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">desired_transform,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// VkSurfaceTransformFlagBitsKHR&nbsp; preTransform</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>31</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">// VkCompositeAlphaFlagBitsKHR&nbsp;&nbsp;&nbsp; compositeAlpha</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>32</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">desired_present_mode,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// VkPresentModeKHR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; presentMode</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>33</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_TRUE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
VkBool32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 clipped</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>34</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">old_swap_chain&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// VkSwapchainKHR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldSwapchain</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>35</code></td><td class="content"><code class="plain">};</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>36</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>37</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( vkCreateSwapchainKHR( Vulkan.Device, &amp;swap_chain_create_info, nullptr, &amp;Vulkan.SwapChain ) != VK_SUCCESS ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>38</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Could not create swap chain!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>39</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>40</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>41</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( old_swap_chain != VK_NULL_HANDLE ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>42</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">vkDestroySwapchainKHR( Vulkan.Device, old_swap_chain, nullptr );</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>43</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>44</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>45</code></td><td class="content"><code class="keyword bold">return</code> <code class="keyword bold">true</code><code class="plain">;</code></td></tr></tbody></table></div></div></div><p><strong>22.</strong><em>Tutorial02.cpp, function CreateSwapChain()</em></p><p>In
 this code example, at the beginning we gathered all the necessary data 
described earlier. Next we create a variable of type 
VkSwapchainCreateInfoKHR. It consists of the following members:</p><ul><li>sType – Normal structure type, which here must be a VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR.</li></ul><ul><li>pNext – Pointer reserved for future use (for some extensions to this extension).</li><li>flags – Value reserved for future use; currently must be set to zero.</li><li>surface – A handle of a created surface that represents windowing system (our application's window).</li><li>minImageCount – Minimal number of images the application requests for a swap chain (must fit into available constraints).</li><li>imageFormat – Application-selected format for swap chain images; must be one of the supported surface formats.</li><li>imageColorSpace
 – Colorspace for swap chain images; only enumerated values of 
format-colorspace pairs may be used for imageFormat and imageColorSpace 
(we can't use format from one pair and colorspace from another pair).</li><li>imageExtent – Size (dimensions) of swap chain images defined in pixels; must fit into available constraints.</li><li>imageArrayLayers
 – Defines the number of layers in a swap chain images (that is, views);
 typically this value will be one but if we want to create multiview or 
stereo (stereoscopic 3D) images, we can set it to some higher value.</li><li>imageUsage
 – Defines how application wants to use images; it may contain only 
values of supported usages; color attachment usage is always supported.</li><li>imageSharingMode
 – Describes image-sharing mode when multiple queues are referencing 
images (I will describe this in more detail later).</li><li>queueFamilyIndexCount
 – The number of different queue families from which swap chain images 
will be referenced; this parameter matters only when 
VK_SHARING_MODE_CONCURRENT sharing mode is used.</li><li>pQueueFamilyIndices
 – An array containing all the indices of queue families that will be 
referencing swap chain images; must contain at least 
queueFamilyIndexCount elements and as in queueFamilyIndexCount this 
parameter matters only when VK_SHARING_MODE_CONCURRENT sharing mode is 
used.</li><li>preTransform – Transformations applied to the swap chain image before it can be presented; must be one of the supported values.</li><li>compositeAlpha
 – This parameter is used to indicate how the surface (image) should be 
composited (blended?) with other surfaces on some windowing systems; 
this value must also be one of the possible values (bits) returned in 
surface capabilities, but it looks like opaque composition (no blending,
 alpha ignored) will be always supported (as most of the games will want
 to use this mode).</li><li>presentMode – Presentation mode that will be used by a swap chain; only supported mode may be selected.</li><li>clipped
 – Connected with ownership of pixels; in general it should be set to 
VK_TRUE if application doesn't want to read from swap chain images (like
 ReadPixels()) as it will allow some platforms to use more optimal 
presentation methods; VK_FALSE value is used in some specific scenarios 
(if I learn more about these scenario I will write about them).</li><li>oldSwapchain
 – If we are recreating a swap chain, this parameter defines an old swap
 chain that will be replaced by a newly created one.</li></ul><p>So 
what's the matter with this sharing mode? Images in Vulkan can be 
referenced by queues. This means that we can create commands that use 
these images. These commands are stored in command buffers, and these 
command buffers are submitted to queues. Queues belong to different 
queue families. And Vulkan requires us to state how many different queue
 families and which of them are referencing these images through 
commands submitted with command buffers.</p><p>If we want to reference 
images from many different queue families at a time we can do so. In 
this case we must provide “concurrent” sharing mode. But this (probably)
 requires us to manage image data coherency by ourselves, that is, we 
must synchronize different queues in such a way that data in the images 
is proper and no hazards occur—some queues are reading data from images,
 but other queues haven't finished writing to them yet.</p><p>We may not
 specify these queue families and just tell Vulkan that only one queue 
family (queues from one family) will be referencing image at a time. 
This doesn't mean other queues can't reference these images. It just 
means they can't do it all at once, at the same time. So if we want to 
reference images from one family and then from another we must 
specifically tell Vulkan: “My image was used inside this queue family, 
but from now on another family, this one, will be referencing it.” Such a
 transition is done using image memory barrier. When only one queue 
family uses a given image at a time, use the “exclusive” sharing mode.</p><p>If
 any of these requirements are not fulfilled, undefined behavior will 
probably occur and we may not rely on the image contents.</p><p>In this 
example we are using only one queue so we don't have to specify 
“concurrent” sharing mode and leave related parameters (queueFamilyCount
 and pQueueFamilyIndices) blank (or nulled, or zeroed).</p><p>So now we can call the <strong>vkCreateSwapchainKHR()</strong>
 function to create a swap chain and check whether this operation 
succeeded. After that (if we are recreating the swap chain, meaning this
 isn't the first time we are creating one) we should destroy the 
previous swap chain. I'll discuss this later.</p><h2>Image Presentation<a class="inpage-nav-anchor" id="inpage-nav-6"></a></h2><p>We
 now have a working swap chain that contains several images. To use 
these images as render targets, we can get handles to all images created
 with a swap chain, but we are not allowed to use them just like that. 
Swap chain images belong to and are owned by the swap chain. This means 
that the application cannot use these images until it asks for them. 
This also means that images are created and destroyed by the platform 
along with a swap chain (not by the application).</p><p>So when the 
application wants to render into a swap chain image or use it in any 
other way, it must first get access to it by asking a swap chain for it.
 If the swap chain makes us wait, we have to wait. And after the 
application finishes using the image it should “return” it by presenting
 it. If we forget about returning images to a swap chain, we will soon 
run out of images and nothing will display on the screen.</p><p>The 
application may also request access to more images at once but they must
 be available. Acquiring access may require waiting. In corner cases, 
when there are too few images in a swap chain and the application wants 
to access too many of them, or if we forget about returning images to a 
swap chain, the application may even wait an infinite amount of time.</p><p>Given
 that there are (usually) at least two images, it may sound strange that
 we have to wait, but it is quite reasonable. Not all images are 
available for the application because they are used by the presentation 
engine. Usually one image is displayed. Additional images may also be 
required for the presentation engine to work properly. So we can't use 
them because it could block the presentation engine in some way. We 
don't know its internal mechanisms and algorithms or the requirements of
 the OS the application is executed on. So the availability of images 
may depend on many factors: internal implementation, OS, number of 
created images, number of images the application wants to use at a 
single time and on the selected presentation mode, which is the most 
important factor from the perspective of this tutorial.</p><p>In 
immediate mode, one image is always presented. Other images (at least 
one) are available for application. When the application posts a 
presentation request (“returns” an image), the image that was displayed 
is replaced with the new one. So if two images are created, only one 
image may be available for application at a single time. When the 
application asks for another image, it must “return” the previous one. 
If it wants two images at a time, it must create a swap chain with more 
images or it will wait forever. When we request more images, in 
immediate mode, the application can ask for (own) “imageCount – 1” 
images at a time.</p><p>In FIFO mode one image is displayed, and the 
rest are placed in a FIFO queue. The length of this queue is always 
equal to “imageCount – 1.” At first, all images may be available to the 
application (because the queue is empty and no image is presented). When
 the application presents an image (“returns” it to a swap chain), it is
 appended to the end of the queue. So as soon as the queue fills, the 
application has to wait for another image until the displayed image is 
released during the vertical blanking period. Images are always 
displayed in the same order they were presented in by the application. 
When the v-sync signal appears, the first image from the queue replaces 
the image that was displayed. The previously displayed image (the 
released one) may become available to the application as it becomes 
unused (isn't presented and is not waiting in the queue). If all images 
are in the queue, the application will wait for the next blanking period
 to access another image. If rendering takes longer than the refresh 
rates, the application will not have to wait at all. This behavior 
doesn't change when there are more images. The internal swap chain queue
 has always “imageCount – 1” elements.</p><p>The last mode available for
 the time being is MAILBOX. As previously mentioned, this mode is most 
similar to the “traditional” triple buffering. One image is always 
displayed. The second image waits in a single-element queue (it always 
has place for only one element). The rest of the images may be available
 for the application. When the application presents an image, the image 
replaces the one waiting in the queue. The image in the queue gets 
displayed only during blanking periods, but the application doesn't need
 to wait for the next image (when there are more than two images). 
MAILBOX mode with only two images behaves identically to FIFO mode—the 
application must wait for the v-sync signal to acquire the next image. 
But with at least three images it immediately may acquire the image that
 was replaced by the “presented” image (the one waiting in the queue). 
That's why I requested one more image than the minimal number. If 
MAILBOX mode is available I want to use it in a manner similar to triple
 buffering (maybe the first thing to do is to check what mode is 
available and after that choose the number of swap chain images based on
 the selected presentation mode).</p><p>I hope these examples help you 
understand why the application must ask for an image if it wants to use 
any. In Vulkan we can only do what is allowed and required—not less and 
usually not too much more.</p><div id="highlighter_54660" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="plain">uint32_t image_index;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="plain">VkResult
 result = vkAcquireNextImageKHR( Vulkan.Device, Vulkan.SwapChain, 
UINT64_MAX, Vulkan.ImageAvailableSemaphore, VK_NULL_HANDLE, 
&amp;image_index );</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="keyword bold">switch</code><code class="plain">( result ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">VK_SUCCESS:</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">VK_SUBOPTIMAL_KHR:</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">VK_ERROR_OUT_OF_DATE_KHR:</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">OnWindowSizeChanged();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">default</code><code class="plain">:</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Problem occurred during swap chain image acquisition!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div><p><strong>23.</strong><em>Tutorial02.cpp, function Draw()</em></p><p>To access an image, we must call the <strong>vkAcquireNextImageKHR()</strong>
 function. During the call we must specify (apart from the device handle
 like in almost all other functions) a swap chain from which we want to 
use an image, a timeout, a semaphore, and a fence object. A function, in
 case of a success, will store the image index in the variable we 
provided the address of. Why an index and not the (handle to) image 
itself? Such a behavior may be convenient (that is, during the 
“preprocessing” phase when we want to prepare as much data needed for 
rendering as possible to not waste time during typical frame rendering) 
but I will describe it later. Just remember that we can check what 
images were created in a swap chain if we want (we just can't use them 
until we are allowed). An array of images will be provided upon such 
query. And the <strong>vkAcquireNextImageKHR()</strong> function stores an index into this very array.</p><p>We
 have to specify a timeout because sometimes images may not be 
immediately available. Trying to use an image before we are allowed to 
will cause an undefined behavior. Specifying a timeout gives the 
presentation engine time to react. If it needs to wait for the next 
vertical blanking period it can do so and we give it a time. So this 
function will block until the given time has passed. We can provide 
maximal available value so the function may even block indefinitely. If 
we provide 0 for the timeout, the function will return immediately. If 
any image was available at the time the call occurred it will be 
provided immediately. If there was no available image, an error will be 
returned stating that the image was not yet ready.</p><p>Once we have 
our image we can use it however we want. Images are processed or 
referenced by commands stored in command buffers. We can prepare command
 buffers earlier (to save as much processing time for rendering as we 
can) and use or submit them here. Or we can prepare the commands now and
 submit them when we're done. In Vulkan, creating command buffers and 
submitting them to queues is the only way to cause operations to be 
performed by the device.</p><p>When command buffers are submitted to 
queues, all their commands start being processed. But a queue cannot use
 an image until it is allowed to, and the semaphore we created earlier 
is for internal queue synchronization—before the queue starts processing
 commands that reference a given image, it should wait on this semaphore
 (until it gets signaled). But this wait doesn't block an application. 
There are two synchronization mechanisms for accessing swap chain 
images: (1) a timeout, which may block an application but doesn't stop 
queue processing, and (2) a semaphore, which doesn't block the 
application but blocks selected queues.</p><p>We now know 
(theoretically) how to render anything (through command buffers). So 
let's now imagine that inside a command buffer we are submitting some 
rendering operations take place. But before the processing will start, 
we should tell the queue (on which this rendering will occur) to wait. 
This all is done within one submit operation.</p><div id="highlighter_600600" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="plain">VkPipelineStageFlags wait_dst_stage_mask = VK_PIPELINE_STAGE_TRANSFER_BIT;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="plain">VkSubmitInfo submit_info = {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_STRUCTURE_TYPE_SUBMIT_INFO,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">// VkStructureType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sType</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">nullptr,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pNext</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 waitSemaphoreCount</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">&amp;Vulkan.ImageAvailableSemaphore,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">// const VkSemaphore&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pWaitSemaphores</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">&amp;wait_dst_stage_mask,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const VkPipelineStageFlags&nbsp; *pWaitDstStageMask;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 commandBufferCount</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">&amp;Vulkan.PresentQueueCmdBuffers[image_index],&nbsp; </code><code class="comments">// const VkCommandBuffer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pCommandBuffers</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 signalSemaphoreCount</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">&amp;Vulkan.RenderingFinishedSemaphore&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">// const VkSemaphore&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pSignalSemaphores</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="plain">};</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>14</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( vkQueueSubmit( Vulkan.PresentQueue, 1, &amp;submit_info, VK_NULL_HANDLE ) != VK_SUCCESS ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>15</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>16</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div><p><strong>24.</strong><em>Tutorial02.cpp, function Draw()</em></p><p>First
 we prepare a structure with information about the types of operations 
we want to submit to the queue. This is done through VkSubmitInfo 
structure. It contains the following fields:</p><ul><li>sType – Standard structure type; here it must be set to VK_STRUCTURE_TYPE_SUBMIT_INFO.</li><li>pNext – Standard pointer reserved for future use.</li><li>waitSemaphoreCount
 – Number of semaphores we want the queue to wait on before it starts 
processing commands from command buffers.</li><li>pWaitSemaphores – 
Pointer to an array with semaphore handles on which queue should wait; 
this array must contain at least waitSemaphoreCount elements.</li><li>pWaitDstStageMask
 – Pointer to an array with the same amount of elements as 
pWaitSemaphores array; it describes the pipeline stages at which each 
(corresponding) semaphore wait will occur; in our example, the queue may
 perform some operations before it starts using the image from the swap 
chain so there is no reason to block all of the operations; the queue 
may start processing some drawing commands and until pipeline gets to 
the stage in which the image is used, it will wait.</li><li>commandBufferCount – Number of command buffers we are submitting for execution.</li><li>pCommandBuffers – Pointer to an array with command buffers handles which must contain at least commandBufferCount elements.</li><li>signalSemaphoreCount – Number of semaphores we want the queue to signal after processing all the submitted command buffers.</li><li>pSignalSemaphores
 – Pointer to an array of at least signalSemaphoreCount elements with 
semaphore handles; these semaphores will be signaled after the queue has
 finished processing commands submitted within this submit information.</li></ul><p>In
 this example we are telling the queue to wait only on one semaphore, 
which will be signaled by the presentation engine when the queue can 
safely start processing commands referencing the swap chain image.</p><p>We
 also submit just one simple command buffer. It was prepared earlier (I 
will describe how to do it later). It only clears the acquired image. 
But this is enough for us to see the selected color in our application's
 window and to see that the swap chain is working properly.</p><p>In the
 code above, the command buffers are arranged in an array (a vector, to 
be more precise). To make it easier to submit the proper command 
buffer—the one that references the currently acquired image—I prepared a
 separate command buffer for each swap chain image. The index of an 
image that the <strong>vkAcquireNextImageKHR()</strong> function 
provides can be used right here. Using image handles (in similar 
scenarios) would require creating maps that would translate the handle 
into a specific command buffer or index. On the other hand, normal 
numbers can be used to just select a specific array element. This is why
 this function gives us indices and not image handles.</p><p>After we 
have submitted a command buffer, all the processing starts in the 
background, on “hardware.” Next, we want to present a rendered image. 
Presenting means that we want our image to be displayed and that we are 
“giving it back” to the swap chain. The code to do this might look like 
this:</p><div id="highlighter_393197" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="plain">VkPresentInfoKHR present_info = {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">// VkStructureType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sType</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">nullptr,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pNext</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 waitSemaphoreCount</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">&amp;Vulkan.RenderingFinishedSemaphore,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">// const VkSemaphore&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pWaitSemaphores</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 swapchainCount</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">&amp;Vulkan.SwapChain,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const VkSwapchainKHR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pSwapchains</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">&amp;image_index,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pImageIndices</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">nullptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
VkResult&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 *pResults</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="plain">};</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="plain">result = vkQueuePresentKHR( Vulkan.PresentQueue, &amp;present_info );</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content"><code class="keyword bold">switch</code><code class="plain">( result ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>14</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">VK_SUCCESS:</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>15</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>16</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">VK_ERROR_OUT_OF_DATE_KHR:</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>17</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">VK_SUBOPTIMAL_KHR:</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>18</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">OnWindowSizeChanged();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>19</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">default</code><code class="plain">:</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>20</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Problem occurred during image presentation!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>21</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>22</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>23</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>24</code></td><td class="content"><code class="keyword bold">return</code> <code class="keyword bold">true</code><code class="plain">;</code></td></tr></tbody></table></div></div></div><p><strong>25.</strong><em>Tutorial02.cpp, function Draw()</em></p><p>An image (or images) is presented by calling the <strong>vkQueuePresentKHR()</strong> function. It may be perceived as submitting a command buffer with only operation: presentation.</p><p>To
 present an image we must specify what images should be presented from 
how many and from which swap chains. We can present many images from 
many swap chains at once (that is, to multiple windows) but only one 
image from a single swap chain can be presented at once. We provide this
 information through the VkPresentInfoKHR structure, which contains the 
following fields:</p><ul><li>sType – Standard structure type, it must be a VK_STRUCTURE_TYPE_PRESENT_INFO_KHR here.</li><li>pNext – Parameter reserved for future use.</li><li>waitSemaphoreCount – The number of semaphores we want the queue to wait on before it presents images.</li><li>pWaitSemaphores
 – Pointer to an array with semaphore handles on which the queue should 
wait; this array must contain at least waitSemaphoreCount elements.</li><li>swapchainCount – The number of swapchains to which we would like to present images.</li><li>pSwapchains
 – An array with swapchainCount elements that contains handles of all 
the swap chains that we &nbsp;want to present images to; any single swap
 chain may only appear once in this array.</li><li>imageIndices – An 
array with swapchainCount elements that contains indices of images that 
we want to present; each element of this array corresponds to a swap 
chain in a pSwapchains array; the image index is the index into the 
array of each swap chain's images (see the next section).</li><li>pResults
 – A pointer to an array of at least swapchainCount element; this 
parameter is optional and can be set to null, but if we provide such an 
array, the result of the presenting operation will be stored in each of 
its elements, for each swap chain respectively; a single value returned 
by the whole function is the same as the worst result value from all 
swap chains.</li></ul><p>Now that we have prepared this structure, we 
can use it to present an image. In this example I'm just presenting a 
single image from a single swap chain.</p><p>Each operation that is performed (or submitted) by calling <strong>vkQueue…()</strong>
 functions (this includes presenting) is appended to the end of the 
queue for processing. Operations are processed in the order in which 
they were submitted. For a presentation, we are presenting an image 
after submitting other command buffers. So the present queue will start 
presenting an image after the processing of all the command buffers is 
done. This ensures that the image will be presented after we are done 
using it (rendering into it) and an image with correct contents will be 
displayed on the screen. But in this example we submit drawing 
(clearing) operations and a present operation to the same queue: the 
PresentQueue. We are doing only simple operations that are allowed to be
 done on a present queue.</p><p>If we want to perform drawing operations
 on a queue that is different than the present operation, we need to 
synchronize the queues. This is done, again, with semaphores, which is 
the reason why we created two semaphores (the second one may not be 
necessary in this example, as we render and present using the same 
queue, but I wanted to show how it should be done in the correct way).</p><p>The
 first semaphore is for presentation engine to tell the queue that it 
can safely use (reference/render into) an image. The second semaphore is
 for us. It is signaled when the operations on the image (rendering into
 it) are done. The submit info structure has a field called 
pSignalSemaphores. It is an array of semaphore handles that will be 
signaled after processing of all of the submitted command buffers is 
finished. So we need to tell the second queue to wait on this second 
semaphore. We store the handle of our second semaphore in the 
pWaitSemaphores field of a VkPresentInfoKHR structure. And the queue to 
which we are submitting the present operation will wait, thanks to this 
second semaphore, until we are done rendering into a given image.</p><p>And that's it. We have displayed our first image using Vulkan!</p><h2>Checking What Images Were Created in a Swap Chain<a class="inpage-nav-anchor" id="inpage-nav-7"></a></h2><p>Previously
 I mentioned swap chain's image indices. Here in this code sample, I 
show you more specifically what I was talking about.</p><div id="highlighter_336771" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="plain">uint32_t image_count = 0;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( (vkGetSwapchainImagesKHR( Vulkan.Device, Vulkan.SwapChain, &amp;image_count, nullptr ) != VK_SUCCESS) ||</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">(image_count == 0) ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Could not get the number of swap chain images!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="plain">std::vector&lt;VkImage&gt; swap_chain_images( image_count );</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( vkGetSwapchainImagesKHR( Vulkan.Device, Vulkan.SwapChain, &amp;image_count, &amp;swap_chain_images[0] ) != VK_SUCCESS ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Could not get swap chain images!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div><p><strong>2 6. </strong><em>-</em></p><p>This
 code sample is a fragment of an imaginary function that checks how many
 and what images were created inside a swap chain. It is done by a 
traditional “double-call,” this time using a <strong>vkGetSwapchainImagesKHR()</strong>
 function. First we call it with the last parameter set to null. This 
way the number of all images created in a swap chain is stored in an 
“image_count” variable and we know how much storage we need to prepare 
for the handles of all images. The second time we call this function, we
 achieve the handles in the array we have provided the address of 
through the last parameter.</p><p>Now we know all the images that the swap chain is using. For the <strong>vkAcquireNextImageKHR()</strong> function and VkPresentInfoKHR structure, the indices I referred to are the indices into this array, an array “returned” by the <strong>vkGetSwapchainImagesKHR()</strong>
 function. It is called an array of a swap chain's presentable images. 
And if any function, in the case of a swap chain, wants us to provide an
 index or returns an index, it is the index of an image in this very 
array.</p><h2>Recreating a Swap Chain<a class="inpage-nav-anchor" id="inpage-nav-8"></a></h2><p>Previously,
 I mentioned that sometimes we must recreate a swap chain, and I also 
said that the old swap chain must be destroyed. The <strong>vkAcquireNextImageKHR()</strong> and <strong>vkQueuePresentKHR()</strong> functions return a result that sometimes causes the <strong>OnWindowSizeChanged()</strong> function to be called. This function recreates the swap chain.</p><p>Sometimes
 a swap chain gets old. This means that the properties of the surface, 
platform, or application window properties changed in such a way that 
the current swap chain cannot be used any more. The most obvious (and 
unfortunately not so good) example is when the window's size changed. We
 cannot create a swap chain image nor can we change its size. The only 
possibility is to destroy and recreate a swap chain. There are also 
situations in which we can still use a swap chain, but it may no longer 
be optimal for surface it was created for.</p><p>These situations are notified by the return codes of the <strong>vkAcquireNextImageKHR()</strong> and <strong>vkQueuePresentKHR()</strong> functions.</p><p>When
 the VK_SUBOPTIMAL_KHR value is returned, we can still use the current 
swap chain for presentation. It will still work but not optimally (that 
is, color precision will be worse). It is advised to recreate swap chain
 when there is an opportunity. A good example is when we have performed 
performance-heavy rendering and after acquiring the image we are 
informed that our image is suboptimal. We don't want to waste all this 
processing and make the user wait much longer for another frame. We just
 present the image and recreate the swap chain as soon as there is an 
opportunity.</p><p>When VK_ERROR_OUT_OF_DATE_KHR is returned we cannot 
use current swap chain and we must recreate it immediately. We cannot 
present using the current swap chain; this operation will fail. We have 
to recreate a swap chain as soon as possible.</p><p>I have mentioned 
that changing the window size is the most obvious, but not so good, 
example of surface properties' changes after which we should recreate a 
swap chain. In this situation we should recreate a swap chain, but we 
may not be notified about it with the mentioned return codes. We should 
monitor the window size changes by ourselves using OS-specific code. And
 that's why the name of this function in our source is <strong>OnWindowSizeChanged</strong>.
 This function is called every time a window's size had changed. But as 
this function only recreates a swap chain (and command buffers) the same
 function can be called here.</p><p>Recreation is done the same way as 
creation. There is a structure member in which we provide a swap chain 
that the new one should replace. But we must implicitly destroy the old 
swap chain after we create the new one.</p><h2>Quick Dive into Command Buffers<a class="inpage-nav-anchor" id="inpage-nav-9"></a></h2><p>You
 now know a lot about swap chains, but there is still one important 
thing you need to know. To explain it, I will briefly show you how to 
prepare drawing commands. That one last important thing about swap 
chains is connected with drawing and preparing command buffers. I will 
present only information about how to clear images, but it is enough to 
check whether our swap chain is working as it should.</p><p>In the first
 tutorial, I described queues and queue families. If we want to execute 
commands on a device we submit them to queues through command buffers. 
To put it in other words: commands are encapsulated inside command 
buffers. Submitting such buffers to queues causes devices to start 
processing commands that were recorded in them. Do you remember OpenGL's
 drawing lists? We could prepare lists of commands that cause the 
geometry to be drawn in a form of a list of, well, drawing commands. The
 situation in Vulkan is similar, but far more flexible and advanced.</p><h3>Creating Command Buffer Memory Pool<a class="inpage-nav-anchor" id="inpage-nav-9-1"></a></h3><p>To
 store commands, a command buffer needs some storage. To prepare space 
for commands we create a pool from which the buffer can allocate its 
memory. We don't specify the amount of space—it is allocated dynamically
 when the buffer is built (recorded).</p><p>Remember that command 
buffers can be submitted only to proper queue families and only the 
types of operations compatible with a given family can be submitted to a
 given queue. Also, the command buffer itself is not connected with any 
queue or queue family, but the memory pool from which buffer allocates 
its memory is. So each command buffer that takes memory from a given 
pool can only be submitted to a queue from a proper queue family—a 
family from (inside?) which the memory pool was created. If there are 
more queues created from a given family, we can submit a command buffer 
to any one of them; the family index is the most important thing here.</p><div id="highlighter_520829" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="plain">VkCommandPoolCreateInfo cmd_pool_create_info = {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">// VkStructureType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sType</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">nullptr,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const void*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pNext</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// VkCommandPoolCreateFlags&nbsp;&nbsp;&nbsp;&nbsp; flags</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">Vulkan.PresentQueueFamilyIndex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 queueFamilyIndex</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="plain">};</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( vkCreateCommandPool( Vulkan.Device, &amp;cmd_pool_create_info, nullptr, &amp;Vulkan.PresentQueueCmdPool ) != VK_SUCCESS ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Could not create a command pool!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div><p><strong>27.</strong><em>Tutorial02.cpp, function CreateCommandBuffers()</em></p><p>To create a pool for command buffer(s) we call a <strong>vkCreateCommandPool()</strong>
 function. It requires us to provide (an address of) a variable of 
structure type VkCommandPoolCreateInfo. It contains the following 
members:</p><ul><li>sType – A usual type of structure that must be equal to VK_STRUCTURE_TYPE_CMD_POOL_CREATE_INFO in this occasion.</li><li>pNext – Pointer reserved for future use.</li><li>flags – Value reserved for future use.</li><li>queueFamilyIndex – Index of a queue family for which this pool is created.</li></ul><p>For our test application, we use only one queue from a presentation family, so we should use its index. Now we can call the <strong>vkCreateCommandPool()</strong>
 function and check whether it succeeded. If yes, the handle to the 
command pool will be stored in a variable we have provided the address 
of.</p><h3>Allocating Command Buffers<a class="inpage-nav-anchor" id="inpage-nav-9-2"></a></h3><p>Next,
 we need to allocate the command buffer itself. Command buffers are not 
created in a typical way; they are allocated from pools. Other objects 
that take their memory from pool objects are also allocated (the pools 
themselves are created). That's why there is a separation in the names 
of the functions vkCreate…() and vkAllocate…().</p><p>As described 
earlier, I allocate more than one command buffer—one for each swap chain
 image that will be referenced by the drawing commands. So each time we 
acquire an image from a swap chain we can submit/use the proper command 
buffer.</p><div id="highlighter_442284" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="plain">uint32_t image_count = 0;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( (vkGetSwapchainImagesKHR( Vulkan.Device, Vulkan.SwapChain, &amp;image_count, nullptr ) != VK_SUCCESS) ||</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">(image_count == 0) ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Could not get the number of swap chain images!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="plain">Vulkan.PresentQueueCmdBuffers.resize( image_count );</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="plain">VkCommandBufferAllocateInfo cmd_buffer_allocate_info = {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO, </code><code class="comments">// VkStructureType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sType</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">nullptr,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const void*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pNext</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">Vulkan.PresentQueueCmdPool,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// VkCommandPool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; commandPool</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>14</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_COMMAND_BUFFER_LEVEL_PRIMARY,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">// VkCommandBufferLevel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; level</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>15</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">image_count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 bufferCount</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>16</code></td><td class="content"><code class="plain">};</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>17</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">(
 vkAllocateCommandBuffers( Vulkan.Device, &amp;cmd_buffer_allocate_info,
 &amp;Vulkan.PresentQueueCmdBuffers[0] ) != VK_SUCCESS ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>18</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Could not allocate command buffers!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>19</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>20</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>21</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>22</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( !RecordCommandBuffers() ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>23</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Could not record command buffers!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>24</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>25</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>26</code></td><td class="content"><code class="keyword bold">return</code> <code class="keyword bold">true</code><code class="plain">;</code></td></tr></tbody></table></div></div></div><p><strong>28.</strong><em>Tutorial02.cpp, function CreateCommandBuffers()</em></p><p>First
 we need to know how many swap chain images were created (a swap chain 
may create more images than we have specified). This was explained in an
 earlier section. We call the <strong>vkGetSwapchainImagesKHR()</strong>
 function with the last parameter set to null. Right now we don't need 
the handles of images, only their total number. After that we prepare an
 array (vector) for a proper number of command buffers and we can create
 a proper number of command buffers. To do this we call the <strong>vkAllocateCommandBuffers()</strong>
 function. It requires us to prepare a structured variable of type 
VkCommandBufferAllocateInfo, which contains the following fields:</p><ul><li>sType – Type of a structure, this time equal to VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO.</li><li>pNext – Normal parameter reserved for future use.</li><li>commandPool – Command pool from which the buffer will be allocating its memory during commands recording.</li><li>level
 – Type (level) of command buffer. There are two levels: primary and 
secondary. Secondary command buffers may only be referenced (used) from 
primary command buffers. Because we don't have any other buffers, we 
need to create primary buffers here.</li><li>bufferCount – The number of command buffers we want to create at once.</li></ul><p>After calling the <strong>vkAllocateCommandBuffers()</strong>
 function, we need to check whether the buffer creations succeeded. If 
yes, we are done allocating command buffers and we are ready to record 
some (simple) commands.</p><h3>Recording Command Buffers<a class="inpage-nav-anchor" id="inpage-nav-9-3"></a></h3><p>Command
 recording is the most important operation we will be doing in Vulkan. 
The recording itself also requires us to provide a lot of information. 
The more information, the more complicated the drawing commands are.</p><p>Here is a set of variables required (in this tutorial) to record command buffers:</p><div id="highlighter_894346" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="plain">uint32_t image_count = </code><code class="keyword bold">static_cast</code><code class="plain">&lt;uint32_t&gt;(Vulkan.PresentQueueCmdBuffers.size());</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="plain">std::vector&lt;VkImage&gt; swap_chain_images( image_count );</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( vkGetSwapchainImagesKHR( Vulkan.Device, Vulkan.SwapChain, &amp;image_count, &amp;swap_chain_images[0] ) != VK_SUCCESS ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Could not get swap chain images!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="plain">VkCommandBufferBeginInfo cmd_buffer_begin_info = {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,&nbsp; </code><code class="comments">//
 
VkStructureType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 sType</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">nullptr,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const 
void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 *pNext</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT, </code><code class="comments">// VkCommandBufferUsageFlags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">nullptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const VkCommandBufferInheritanceInfo&nbsp; *pInheritanceInfo</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>14</code></td><td class="content"><code class="plain">};</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>15</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>16</code></td><td class="content"><code class="plain">VkClearColorValue clear_color = {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>17</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">{ 1.0f, 0.8f, 0.4f, 0.0f }</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>18</code></td><td class="content"><code class="plain">};</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>19</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>20</code></td><td class="content"><code class="plain">VkImageSubresourceRange image_subresource_range = {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>21</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VK_IMAGE_ASPECT_COLOR_BIT,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
VkImageAspectFlags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 aspectMask</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>22</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 baseMipLevel</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>23</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 levelCount</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>24</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 baseArrayLayer</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>25</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 layerCount</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>26</code></td><td class="content"><code class="plain">};</code></td></tr></tbody></table></div></div></div><p><strong>29.</strong><em>Tutorial02.cpp, function RecordCommandBuffers()</em></p><p>First
 we get the handles of all the swap chain images, which will be used in 
drawing commands (we will just clear them to one single color but 
nevertheless we will use them). We already know the number of images, so
 we don't have to ask for it again. The handles of images are stored in a
 vector after calling the <strong>vkGetSwapchainImagesKHR()</strong> function.</p><p>Next,
 we need to prepare a variable of structured type 
VkCommandBufferBeginInfo. It contains the information necessary in more 
typical rendering scenarios (like render passes). We won't be doing such
 operations here and that's why we can set almost all parameters to 
zeros or nulls. But, for clarity, the structure contains the following 
fields:</p><ul><li>sType – Structure type, this time it must be set to VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO.</li><li>pNext – Pointer reserved for future use, leave it to null.</li><li>flags – Parameter defining preferred usage of a command buffer.</li><li>pInheritanceInfo – Parameter pointing to another structure that is used in more typical rendering scenarios.</li></ul><p>Command
 buffers gather commands. To store commands in command buffers, we 
record them. The above structure provides some necessary information for
 the driver to prepare for and optimize the recording process.</p><p>In 
Vulkan, command buffers are divided into primary and secondary. Primary 
command buffers are typical command buffers similar to drawing lists. 
They are independent, individual “beings” and they (and only they) may 
be submitted to queues. Secondary command buffers can also store 
commands (we also record them), but they may only be referenced from 
within primary command buffers (we can call secondary command buffers 
from within primary command buffers like calling OpenGL's drawing lists 
from another drawing lists). We can't submit secondary command buffers 
directly to queues.</p><p>All of this information will be described in more detail in a forthcoming tutorial.</p><p>In
 this simple example we want to clear our images with one single value. 
So next we set up a color that will be used for clearing. You can pick 
any value you like. I used a light orange color.</p><p>The last variable
 in the code above specifies the parts of the image that our operations 
will be performed on. Our image consists of only one mipmap level and 
one array level (no stereoscopic buffers, and so on). We set values in 
the VkImageSubresourceRange structure accordingly. This structure 
contains the following fields:</p><ul><li>aspectMask – Depends on the 
image format as we are using images as color render targets (they have 
“color” format) so we specify “color aspect” here.</li><li>baseMipLevel – First mipmap level that will be accessed (modified).</li><li>levelCount – Number of mipmap levels on which operations will be performed (including the base level).</li><li>baseArrayLayer – First array layer that will be accessed (modified).</li><li>arraySize – &nbsp;Number of layers the operations will be performed on (including the base layer).</li></ul><p>We are almost ready to record some buffers.</p><h3>Image Layouts and Layout Transitions<a class="inpage-nav-anchor" id="inpage-nav-9-4"></a></h3><p>The
 last variable required in the above code example (of type 
VkImageSubresourceRange) specifies the parts of the image that 
operations will be performed on. In this lesson we only clear an image. 
But we also need to perform <strong><em>resource transitions</em></strong>.
 Remember the code when we selected a use for a swap chain image before 
the swap chain itself was created? Images may be used for different 
purposes. They may be used as render targets, as textures that can be 
sampled from inside the shaders, or as a data source for copy/blit 
operations (data transfers). We must specify different usage flags 
during image creation for the different types of operations we want to 
perform with or on images. We can specify more usage flags if we want 
(if they are supported; “color attachment” usage is always available for
 swap chains). But image usage specification is not the only thing we 
need to do. Depending on the type of operation, images may be 
differently allocated or may have a different layout in memory. Each 
type of image operation may be connected with a different “image 
layout.” We can use a general layout that is supported by all 
operations, but it may not provide the best performance. For specific 
usages we should always use dedicated layouts.</p><p>If we create an 
image with different usages in mind and we want to perform different 
operations on it, we must change the image's current layout before we 
can perform each type of operation. To do this, we must transition from 
the current layout to another layout that is compatible with the 
operations we are about to execute.</p><p>Each image we create is 
created (generally) with an undefined layout, and we must transition 
from it to another layout if want to use the image. But 
swap-chain-created images have VK_IMAGE_LAYOUT_PRESENT_SOURCE_KHR 
layouts. This layout, as the name suggests, is designed for the image to
 be used (presented) by the presentation engine (that is, displayed on 
the screen). So if we want to perform some operations on swap chain 
images, we need to change their layouts to ones compatible with the 
desired operations. And after we have finished with processing the 
images (that is, rendering into them) we need to transition their 
layouts back to the VK_IMAGE_LAYOUT_PRESENT_SOURCE_KHR. Otherwise, the 
presentation engine will not be able to use these images and undefined 
behavior may occur.</p><p>To transition from one layout to another one, <em>image memory barriers</em>
 are used. With them we can specify the old layout (current) we are 
transitioning from and the new layout we are transitioning to. The old 
layout must always be equal to the current or undefined layout. When we 
specify the old layout as undefined, image contents may be discarded 
during transition. This allows the driver to perform some optimizations.
 If we want to preserve image contents we must specify a layout that is 
equal to the current layout.</p><p>The last variable of type 
VkImageSubresourceRange in the code example above is also used for image
 transitions. It defines what “parts” of the image are changing their 
layout and is required when preparing an image memory barrier.</p><h3>Recording Command Buffers<a class="inpage-nav-anchor" id="inpage-nav-9-5"></a></h3><p>The
 last step is to record a command buffer for each swap chain image. We 
want to clear the image to some arbitrary color. But first we need to 
change the image layout and change it back after we are done. Here is 
the code that does that:</p><div id="highlighter_522076" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="keyword bold">for</code><code class="plain">( uint32_t i = 0; i &lt; image_count; ++i ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VkImageMemoryBarrier barrier_from_present_to_clear = {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">//
 
VkStructureType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 sType</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">nullptr,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const 
void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 *pNext</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">VK_ACCESS_MEMORY_READ_BIT,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
VkAccessFlags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 srcAccessMask</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">VK_ACCESS_TRANSFER_WRITE_BIT,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">//
 
VkAccessFlags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 dstAccessMask</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">VK_IMAGE_LAYOUT_UNDEFINED,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
VkImageLayout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 oldLayout</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">//
 
VkImageLayout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 newLayout</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Vulkan.PresentQueueFamilyIndex,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">//
 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 srcQueueFamilyIndex</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Vulkan.PresentQueueFamilyIndex,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">//
 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 dstQueueFamilyIndex</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">swap_chain_images[i],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
VkImage&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 image</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">image_subresource_range&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
VkImageSubresourceRange&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 subresourceRange</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">};</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>14</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>15</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">VkImageMemoryBarrier barrier_from_clear_to_present = {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>16</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">//
 
VkStructureType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 sType</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>17</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">nullptr,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// const 
void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 *pNext</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>18</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">VK_ACCESS_TRANSFER_WRITE_BIT,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">//
 
VkAccessFlags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 srcAccessMask</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>19</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">VK_ACCESS_MEMORY_READ_BIT,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
VkAccessFlags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 dstAccessMask</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>20</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">//
 
VkImageLayout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 oldLayout</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>21</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">//
 
VkImageLayout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 newLayout</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>22</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Vulkan.PresentQueueFamilyIndex,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">//
 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 srcQueueFamilyIndex</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>23</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Vulkan.PresentQueueFamilyIndex,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">//
 
uint32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 dstQueueFamilyIndex</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>24</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">swap_chain_images[i],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
VkImage&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 image</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>25</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">image_subresource_range&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </code><code class="comments">// 
VkImageSubresourceRange&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 subresourceRange</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>26</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">};</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>27</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>28</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">vkBeginCommandBuffer( Vulkan.PresentQueueCmdBuffers[i], &amp;cmd_buffer_begin_info );</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>29</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">vkCmdPipelineBarrier( Vulkan.PresentQueueCmdBuffers[i],
 VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, 0, 0, 
nullptr, 0, nullptr, 1, &amp;barrier_from_present_to_clear );</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>30</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>31</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">vkCmdClearColorImage( Vulkan.PresentQueueCmdBuffers[i],
 swap_chain_images[i], VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 
&amp;clear_color, 1, &amp;image_subresource_range );</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>32</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>33</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">vkCmdPipelineBarrier( Vulkan.PresentQueueCmdBuffers[i],
 VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, 
0, 0, nullptr, 0, nullptr, 1, &amp;barrier_from_clear_to_present );</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>34</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">( vkEndCommandBuffer( Vulkan.PresentQueueCmdBuffers[i] ) != VK_SUCCESS ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>35</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Could not record command buffers!"</code> <code class="plain">&lt;&lt; std::endl;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>36</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="keyword bold">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>37</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>38</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>39</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>40</code></td><td class="content"><code class="keyword bold">return</code> <code class="keyword bold">true</code><code class="plain">;</code></td></tr></tbody></table></div></div></div><p><strong>30.</strong><em>Tutorial02.cpp, function RecordCommandBuffers()</em></p><p>This
 code is placed inside a loop. We are recording a command buffer for 
each swap chain image. That's why we needed a number of images. Image 
handles are also needed here. We need to specify them for image memory 
barriers and during image clearing. But recall that I said we can't use 
swap chain images until we are allowed to, until we acquire the image 
from the swap chain. That's true, but we aren't using them here. We are 
only preparing commands. The usage itself is performed when we submit 
operations (a command buffer) to the queue for execution. Here we are 
just telling Vulkan that in the future, take this picture and do this 
with it, then that, and after that something more. This way we can 
prepare as much work as we can before we start the main rendering loop 
and we avoid switches, ifs, jumps, and other branches during the real 
rendering. This scenario won't be so simple in real life, but I hope the
 example is clear.</p><p>In the above code above, we are first preparing
 two image memory barriers. Memory barriers are used to change three 
different things in the case of images. From the tutorial point of view,
 only the layouts are interesting right now but we need to properly set 
all fields. To set up a memory barrier we need to prepare a variable of 
type VkImageMemoryBarrier, which contains the following fields:</p><ul><li>sType – Structure type which here must be set to VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER.</li><li>pNext – Leave it null, pointer not used right now.</li><li>srcAccessMask – Types of memory operations done on the image before the barrier.</li><li>dstAccessMask – Types of memory operations that will take place after the barrier.</li><li>oldLayout
 – Layout from which we are transitioning; it should always be equal to 
the current layout (which in this example, for a first barrier, would be
 VK_IMAGE_LAYOUT_PRESENT_SOURCE_KHR).Or we can use an undefined layout, 
which will let the driver perform some optimizations but the contents of
 the image may be discarded. Since we don't need the contents, we can 
use an undefined layout here.</li><li>newLayout – A layout that is 
compatible with operations we will be performing after the barrier; we 
want to do image clears; to do that we need to specify 
VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL layout. We should always use a 
specific, dedicated layout.</li><li>srcQueueFamilyIndex – A queue family index that was referencing the image previously.</li><li>dstQueueFamilyIndex
 – A family index from which queues will be referencing images after the
 barrier (this refers to the swap chain sharing mode I was describing 
earlier).</li><li>image – handle to image itself.</li><li>subresourceRange
 – A structure describing parts of an image we want to perform 
transitions on; this is that last variable from the previous code 
example.</li></ul><p>Some notes are necessary regarding access masks and
 family indices. In this example before the first barrier and after the 
second barrier only the presentation engine has access to the image. The
 presentation engine only reads from the image (it doesn't modify it) so
 we set srcAccessMask in the first barrier and dstAccessMask in the 
second barrier to VK_ACCESS_MEMORY_READ_BIT. This indicates that the 
memory associated with the image is read-only (image contents are not 
modified before the first barrier and after the second barrier). In our 
command buffer we will only clear an image. This operation belongs to 
the so-called “transfer” operations. That is why I've set the value of 
VK_ACCESS_TRANSFER_WRITE_BIT in the first barrier in dstAccessMask field
 and in the srcAccessMask field of the second barrier.</p><p>I won't go 
into more detail about queue family indices, but if a queue used for 
graphics operations and presentation are the same, srcQueueFamilyIndex 
and dstQueueFamilyIndex will be equal, and the hardware won't make any 
modifications regarding image access from the queues. But remember that 
we have specified that only one queue at a time will access/use the 
image. So if these queues are different, we inform the hardware here 
about the “ownership” change, that different queue will now access the 
image. And this is all the information you need right now to properly 
set up barriers.</p><p>We need to create two barriers: one that changes 
the layout from the “present source” (or undefined) to ”transfer dst”. 
This barrier is used at the beginning of a command buffer, when the 
previously presentation engine used an image and now we want to use it 
and modify it. The second barrier is used to change the layout back into
 the “present source” when we are done using the images and we can give 
them back to a swap chain. This barrier is set at the end of a command 
buffer.</p><p>Now we are ready to start recording our commands by calling the <strong>vkBeginCommandBuffer()</strong>
 function. We provide a handle to a command buffer and an address of a 
variable of type VkCommandBufferBeginInfo and we are ready to go. Next 
we set up a barrier to change the image layout. We call the <strong>vkCmdPipelineBarrier()</strong>
 function, which takes quite a few parameters but in this example the 
only relevant ones are the first—the command buffer handle—and the last 
two: number of elements (barriers) of an array and a pointer to first 
element of an array containing the addresses of variables of type 
VkImageMemoryBarrier. Elements of this array describe images, their 
parts, and the types of transitions that should occur. After the barrier
 we can safely perform any operations on the swap chain image that are 
compatible with the layout we have transitioned images to. The general 
layout is compatible with all operations but with a (probably) reduced 
performance.</p><p>In the example we are only clearing images so we call the <strong>vkCmdClearColorImage()</strong>
 function. It takes a handle to a command buffer, handle to an image, 
current layout of an image, pointer to a variable with clear color 
value, number of subresources (number of elements in the array from the 
last parameter), and an array of pointers to variables of type 
VkImageSubresourceRange. Elements in the last array specify what parts 
of the image we want to clear (we don't have to clear all mipmaps or 
array levels of an image if we don't want to).</p><p>And at the end of 
our recording session we set up another barrier that transitions the 
image layout back to a “present source” layout. It is the only layout 
that is compatible with the present operations performed by the 
presentation engine.</p><p>Now we can call the <strong>vkEndCommandBuffer()</strong>
 function to inform that we have ended recording a command buffer. If 
something went wrong during recording we will be informed about it 
through the value returned by this function. If there were errors, we 
cannot use the command buffer, and we'll need to record it once again. 
If everything is fine we can use the command buffer later to tell our 
device to perform operations stored in it just by submitting the buffer 
to a queue.</p><h2>Tutorial 2 Execution<a class="inpage-nav-anchor" id="inpage-nav-10"></a></h2><p>In
 this example, if everything went fine, we should see a window with a 
light-orange color displayed inside it. The contents of a window should 
look similar to this:</p><p style="text-align:center"><img alt="" src="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/api-vulkan-part-2-result.jpg"></p><h2>Cleaning Up<a class="inpage-nav-anchor" id="inpage-nav-11"></a></h2><p>Now
 you know how to create a swap chain, display images in a window and 
perform simple operations that are executed on a device. We have created
 command buffers, recorded them, and presented on the screen. Before we 
close the application, we need to clean up the resources we were using. 
In this tutorial I have divided cleaning into two functions. The first 
function clears (destroys) only those resources that should be recreated
 when the swap chain is recreated (that is, after the size of an 
application's window has changed).</p><div id="highlighter_44612" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( Vulkan.Device != VK_NULL_HANDLE ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">vkDeviceWaitIdle( Vulkan.Device );</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">( (Vulkan.PresentQueueCmdBuffers.size() &gt; 0) &amp;&amp; (Vulkan.PresentQueueCmdBuffers[0] != VK_NULL_HANDLE) ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">vkFreeCommandBuffers( Vulkan.Device, Vulkan.PresentQueueCmdPool, </code><code class="keyword bold">static_cast</code><code class="plain">&lt;uint32_t&gt;(Vulkan.PresentQueueCmdBuffers.size()), &amp;Vulkan.PresentQueueCmdBuffers[0] );</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Vulkan.PresentQueueCmdBuffers.clear();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">( Vulkan.PresentQueueCmdPool != VK_NULL_HANDLE ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">vkDestroyCommandPool( Vulkan.Device, Vulkan.PresentQueueCmdPool, nullptr );</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Vulkan.PresentQueueCmdPool = VK_NULL_HANDLE;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div><p><strong>31.</strong><em>Tutorial02.cpp, Clear()</em></p><p>First
 we must be sure that no operations are executed on the device's queues 
(we can't destroy a resource that is used by the currently processed 
commands). We can check it by calling <strong>vkDeviceWaitIdle()</strong> function. It will block until all operations are finished.</p><p>Next
 we free all the allocated command buffers. In fact this operation is 
not necessary here. Destroying a command pool implicitly frees all 
command buffers allocated from a given pool. But I want to show you how 
to explicitly free command buffers. Next we destroy the command pool 
itself.</p><p>Here is the code that is responsible for destroying all of the resources created in this lesson:</p><div id="highlighter_144050" class="syntaxhighlighter  "><div class="bar"><div class="toolbar"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2#copyToClipboard" title="Copy Code" style="width: 16px; height: 16px;" class="item copyToClipboard">Copy Code</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="plain">Clear();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( Vulkan.Device != VK_NULL_HANDLE ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">vkDeviceWaitIdle( Vulkan.Device );</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">( Vulkan.ImageAvailableSemaphore != VK_NULL_HANDLE ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">vkDestroySemaphore( Vulkan.Device, Vulkan.ImageAvailableSemaphore, nullptr );</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">( Vulkan.RenderingFinishedSemaphore != VK_NULL_HANDLE ) {</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">vkDestroySemaphore( Vulkan.Device, Vulkan.RenderingFinishedSemaphore, nullptr );</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">( Vulkan.SwapChain != VK_NULL_HANDLE ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">vkDestroySwapchainKHR( Vulkan.Device, Vulkan.SwapChain, nullptr );</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>14</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>15</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">vkDestroyDevice( Vulkan.Device, nullptr );</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>16</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>17</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>18</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( Vulkan.PresentationSurface != VK_NULL_HANDLE ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>19</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">vkDestroySurfaceKHR( Vulkan.Instance, Vulkan.PresentationSurface, nullptr );</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>20</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>21</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>22</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( Vulkan.Instance != VK_NULL_HANDLE ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>23</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">vkDestroyInstance( Vulkan.Instance, nullptr );</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>24</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>25</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>26</code></td><td class="content"><code class="keyword bold">if</code><code class="plain">( VulkanLibrary ) {</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>27</code></td><td class="content"><code class="preprocessor">#if defined(VK_USE_PLATFORM_WIN32_KHR)</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>28</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">FreeLibrary( VulkanLibrary );</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>29</code></td><td class="content"><code class="preprocessor">#elif defined(VK_USE_PLATFORM_XCB_KHR) || defined(VK_USE_PLATFORM_XLIB_KHR)</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>30</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;</code><code class="plain">dlclose( VulkanLibrary );</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>31</code></td><td class="content"><code class="preprocessor">#endif</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>32</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div><p><strong>32.</strong><em>Tutorial02.cpp, destructor</em></p><p>First
 we destroy the semaphores (remember they cannot be destroyed when they 
are in use, that is, when a queue is waiting on a given semaphore). 
After that we destroy a swap chain. Images that were created along with 
it are automatically destroyed, and we don't need to do it by ourselves 
(we are even not allowed to). Next the device is destroyed. We also need
 to destroy the surface that represents our application's window. At the
 end, the Vulkan instance destruction takes place and the graphics 
driver's dynamic library is unloaded. Before we perform each step we 
also check whether a given resource was properly created. We can't 
destroy resources that weren't properly created.</p><h2>Conclusion<a class="inpage-nav-anchor" id="inpage-nav-12"></a></h2><p>In
 this tutorial you learned how to display on a screen anything that was 
created with Vulkan API. To brief review the steps: First we enabled the
 proper instance level extensions. Next we created an application 
window's Vulkan representation called a surface. Then we chose a device 
with a queue family that supported presentation and created a logical 
device (don't forget about enabling device-level extensions!)</p><p>After
 that we created a swap chain. To do that we first acquired a set of 
parameters describing our surface and then chose values for proper swap 
chain creation. Those values had to fit into a surface's supported 
constraints.</p><p>To draw something on the screen we learned how to 
create and record command buffers, which also included image's layout 
transitions for which image memory barriers (pipeline barriers) were 
used. We cleared images so we could see the selected color being 
displayed on screen.</p><p>And we also learned how to present a given 
image on the screen, which included acquiring an image, submitting a 
command buffer, and the presentation process itself.</p><p><strong>Next up: <a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-3">API without Secrets: Introduction to Vulkan* Part 3: First Triangle</a></strong></p><p>This sample source code is released under the <a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/intel-sample-source-code-license-agreement/">Intel Sample Source Code License Agreement</a>.</p>
</div></div><div class="field field-name-field-protected-attachments field-type-file field-label-hidden"><div class="field-items"></div></div><div class="optimization-notice">
  For more complete information about compiler optimizations, see our <a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/optimization-notice#opt-en">Optimization Notice</a>.</div></div>
    
</article>

<div class="comments-wrapper notranslate">
  <section id="comments" class="comments comment-wrapper">

              <div class="title-wrapper clearfix">

        <h2 class="comments__title title">2 comments</h2>
        <a href="#" class="to-top"><span class="icon-caret-up">Top</span></a>
                  <div class="comment-subscribe">
                      </div>
              </div>
        
    <a id="comment-1879743"></a>
<article class="comment comment-by-node-author first odd clearfix" about="/en-us/comment/1879743#comment-1879743" typeof="sioc:Post sioct:Comment">
  <header>
    <p class="submitted ctHidden" data-hj-masked="">
      <span property="dc:date dc:created" content="2016-08-02T03:50:12-07:00" datatype="xsd:dateTime" rel="sioc:has_creator"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/user/1183993">Pawel L.</a> said on Aug 2,2016</span>    </p>

            
      </header>

  <div class="comment-content-wrapper">
              <span class="user-picture">
      <a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/user/1183993" title="View user profile.">
        <img typeof="foaf:Image" src="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/3379051040466063749361857718207o.jpg" alt="plapins's picture" title="plapins's picture">
      </a>
    </span>
    
    <div class="comment-content">
      <span rel="sioc:reply_of" resource="/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2" class="rdf-meta element-hidden"></span><div class="field field-name-comment-body field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item even" property="content:encoded"><p>@<a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/user/1457537" title="View user profile.">Vlad S.</a></p>
<p>Yes, TRANSFER_DST usage may not be supported on every driver. Only COLOR_ATTACHMENT usage is obligatory.</p>
<p>But the fact that Your hardware doesn't support this usage, it 
doesn't mean it won't work. It may work on one hardware, but on other 
may not.&nbsp;<span>Try it, maybe You are lucky, but don't rely on it.</span></p>
</div></div></div>      <div class="comment-contextual-links">
                <span class="icon-edit"></span>
        <ul class="links inline"><li class="comment_forbidden first last"><span><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/user/login?destination=node/623623%23comment-form">Log in</a> to post comments</span></li>
</ul>              </div>
    </div>

  </div>

</article>
<a id="comment-1879644"></a>
<article class="comment last even clearfix" about="/en-us/comment/1879644#comment-1879644" typeof="sioc:Post sioct:Comment">
  <header>
    <p class="submitted ctHidden" data-hj-masked="">
      <span property="dc:date dc:created" content="2016-08-06T11:11:01-07:00" datatype="xsd:dateTime" rel="sioc:has_creator"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/user/1457537">Vlad S.</a> said on Aug 6,2016</span>    </p>

            
      </header>

  <div class="comment-content-wrapper">
              <span class="user-picture-icon">
      <a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/user/1457537"><span data-icon=""></span></a></span>
    
    <div class="comment-content">
      <span rel="sioc:reply_of" resource="/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2" class="rdf-meta element-hidden"></span><div class="field field-name-comment-body field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item even" property="content:encoded"><p>Unfortunately
 my HD 8570 didn't return VK_BUFFER_USAGE_TRANSFER_DST_BIT on 
supportedUsageFlags, so I can't call vkCmdClearColorImage, so this 
feature is not universal, watch out for old hardware!</p>
<p>EDIT: On closer examination it turned out it was my fault, I mixed up
 order of operations and was creating swap chain with incorrect surface.
 I forgot that creating a device requires a valid surface already at 
this point and that caused a whole chain reaction of problems down the 
line, sudden crashes, freezing windows, flags not being returned... 
After enabling validation layers I quickly traced down the problem 
and&nbsp;<span>VK_BUFFER_USAGE_TRANSFER_DST_BIT was returned.</span></p>
</div></div></div>      <div class="comment-contextual-links">
                <span class="icon-edit"></span>
        <ul class="links inline"><li class="comment_forbidden first last"><span><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/user/login?destination=node/623623%23comment-form">Log in</a> to post comments</span></li>
</ul>              </div>
    </div>

  </div>

</article>

    <div class="comment-form-wrapper">
      <h2 class="comments__form-title title comment-form">Add a Comment</h2>
              <a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/user/login?language=en-us&amp;destination=node/623623&amp;https=1" class="sign-in">Sign in</a>            <p class="tech-support">Have a technical question? <a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/forum">Visit our forums</a>. <span>Have site or software product issues? <a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/contact">Contact support</a>.<span></span></span></p>
          </div>

  </section>
</div>
                <div id="action-secondary-tabs">
                  </div>

      </div>

      
      
    </div>
  </div>

    <nav class="page-top-second-footer">
      <div class="page-top-second-footer-inner clearfix notranslate" id="navfooter" data-wap_type="navfooter"><div id="block-idz-zero-idz-zero-share-widget-block-clone" class="block block-idz-zero first last odd cloned-share-widget">

      
  <div class="show_all_widget notranslate">
  <div class="item-list"><ul id="wap-social" data-wap_type="socialshare"><li class="facebook first"><a href="https://web.archive.org/web/20200503051336/https://www.facebook.com/sharer/sharer.php?u=https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2" class="icon-logo-facebook" target="_blank" data-wap_ref="facebook">Share</a></li>
<li class="twitter"><a href="https://web.archive.org/web/20200503051336/https://twitter.com/intent/tweet?text=API+without+Secrets%3A+Introduction+to+Vulkan%2A+Part+2%3A+Swap+Chain%3A&amp;url=https%3A%2F%2Fsoftware.intel.com%2Fen-us%2Farticles%2Fapi-without-secrets-introduction-to-vulkan-part-2&amp;hashtags=IntelSoftware" class="icon-logo-twitter-bird" target="_blank" data-wap_ref="twitter" data-hashtags="IntelSoftware" data-text="API without Secrets: Introduction to Vulkan* Part 2: Swap Chain:" data-url="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2">Tweet</a></li>
<li class="google"><a href="https://web.archive.org/web/20200503051336/https://plus.google.com/share?url=https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2" class="icon-logo-gplus" target="_blank" data-wap_ref="twitter">Share</a></li>
<li class="send last"><a href="https://web.archive.org/web/20200503051336/mailto:/?subject=API%20without%20Secrets:%20Introduction%20to%20Vulkan*%20Part%202:%20Swap%20Chain&amp;body=https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-2" class="icon-email" target="_self" data-wap_ref="send">Send</a></li>
</ul></div></div>
<div class="showsharewidget notranslate">
  <span class="share_label icon-zz_000005_share">
    Share  </span>
</div>


</div>
        <ul class="menu js-processed"><li class="menu__item is-expanded first expanded footer-columns-3" style="height: 163px;"><a class="menu__link">Connect</a><ul class="menu js-processed"><li class="menu__item is-leaf first leaf"><a href="https://web.archive.org/web/20200503051336/https://software.seek.intel.com/gamedevnewsLP" target="_blank" class="menu__link">Join the Intel® GameDev Program</a></li>
<li class="menu__item is-leaf leaf"><a href="https://web.archive.org/web/20200503051336/https://devmesh.intel.com/" target="_blank" class="menu__link">Collaborate on Developer Mesh</a></li>
<li class="menu__item is-leaf last leaf"><a href="https://web.archive.org/web/20200503051336/https://twitch.tv/IntelGameDev" target="_blank" class="menu__link">IntelGameDev on Twitch.tv</a></li>
</ul></li>
<li class="menu__item is-expanded expanded footer-columns-3" style="height: 163px;"><a class="menu__link">Game Dev Resources</a><ul class="menu js-processed"><li class="menu__item is-leaf first leaf"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/gamedev/join" class="menu__link">About Our Program</a></li>
<li class="menu__item is-leaf leaf"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/gamedev/documentation" class="menu__link menu-node-unpublished menu-node-unpublished menu-node-unpublished menu-node-unpublished">Library</a></li>
<li class="menu__item is-leaf leaf"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/forums/developing-games-and-graphics-on-intel" class="menu__link">Forum</a></li>
<li class="menu__item is-leaf leaf"><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/articles/intel-graphics-developers-guides" class="menu__link">Graphics Guides</a></li>
<li class="menu__item is-leaf last leaf"><a href="https://web.archive.org/web/20200503051336/https://downloadcenter.intel.com/default.aspx" target="_blank" class="menu__link">Graphics Drivers</a></li>
</ul></li>
<li class="menu__item is-expanded last expanded footer-columns-3" style="height: 163px;"><a class="menu__link">Intel Gaming</a><ul class="menu js-processed"><li class="menu__item is-leaf first leaf"><a href="https://web.archive.org/web/20200503051336/https://gameplay.intel.com/?=intelgamedev" target="_blank" class="menu__link">Gameplay.Intel.com</a></li>
<li class="menu__item is-leaf leaf"><a href="https://web.archive.org/web/20200503051336/https://www.intel.com/content/www/us/en/gaming/gaming-systems.html" target="_blank" class="menu__link">Intel® Gaming Site</a></li>
<li class="menu__item is-leaf leaf"><a href="https://web.archive.org/web/20200503051336/https://www.intel.com/content/www/us/en/gaming/esports.html" target="_blank" class="menu__link">eSports</a></li>
<li class="menu__item is-leaf last leaf"><a href="https://web.archive.org/web/20200503051336/https://twitter.com/IntelGaming" target="_blank" class="menu__link">Intel Gaming on Twitter</a></li>
</ul></li>
</ul>      </div>
    </nav>
  
<div class="page-footer notranslate">
  <div id="idz-rateus">
  <div id="survey_container">
    <div id="survey_button">
      <div class="rate-star">
        <span class="rate-txt">Rate Us </span>
        <span class="icon-star-empty"></span><span class="icon-star-empty"></span><span class="icon-star-empty"></span>
      </div>
    </div>
    <div class="survey_iframe_container">
      <div id="survey_frame">
        <div class="scrollable">
          <iframe id="iframe_survey" width="100%" height="100%" frameborder="0" data-src="https://idz.qualtrics.com/SE/?SID=SV_eai43JosW74IFxz" data-ruffle-polyfilled=""></iframe>
        </div>
      </div>
      <div id="close_button">
        <div id="close_survey">
          <img src="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/bwc_close.png">
        </div>
      </div>
      <div id="open_survey">
        <div class="survey_up">
        </div>
      </div>
    </div>
  </div>
</div>
  <div id="block-bean-homepage-newsletter-subscribe" class="block block-bean first odd" data-wap_type="navfooter" style="margin-left: 148px;">
  <div class="entity entity-bean bean-idz-newsletter-subscribe view-mode-default clearfix" about="/en-us/block/homepage-newsletter-subscribe" typeof="">
    <div class="content">
      <div class="field field-name-field-subscribed-action-text field-type-text field-label-hidden">
        <div class="field-items">
          <div class="field-item even "><a href="https://web.archive.org/web/20200503051336/https://software.intel.com/en-us/newsletter/subscribe">Get the Newsletter</a></div>
        </div>
      </div>
    </div>
  </div>
</div>
  <div id="block-idz-responsive-blocks-idz-responsive-superfooter" class="block block-idz-responsive-blocks even" data-wap_type="socialreferral">
  <footer class="l-language-footer">
    <div class="limiter">
      <section class="look-for-intel">
        <span id="look-for-intel-expander"></span>
        <span class="blurb">Follow us:</span>

        <div class="item-list notranslate">
          <div class="item-list"><ul><li class="facebook first"><a href="https://web.archive.org/web/20200503051336/http://facebook.com/inteldeveloperzone" target="_blank" class="icon-logo-facebook">Facebook</a></li>
<li class="twitter-bird"><a href="https://web.archive.org/web/20200503051336/http://twitter.com/intelsoftware" target="_blank" class="icon-logo-twitter-bird">Twitter</a></li>
<li class="github"><a href="https://web.archive.org/web/20200503051336/https://github.com/IntelSoftware" target="_blank" class="icon-zz_000003_githuboctokitty">Github</a></li>
<li class="twitch"><a href="https://web.archive.org/web/20200503051336/https://twitch.tv/IntelGameDev" target="_blank" class="icon-zz_000003_twitch">Twitch</a></li>
<li class="youtube last"><a href="https://web.archive.org/web/20200503051336/https://www.youtube.com/user/intelswnetwork" target="_blank" class="icon-logo-youtube">YouTube</a></li>
</ul></div>        </div>
      </section>
    </div>
  </footer>
</div>
  <div id="block-idz-responsive-blocks-idz-responsive-legal-footer" class="block block-idz-responsive-blocks last odd" data-wap_type="navfooter">

  <footer class="l-legal-footer">
    <nav class="menu">
      <ul>
                <li>
          <a href="https://web.archive.org/web/20200503051336/http://www.intel.com/">© Intel Corporation</a>        </li>
        <li>
          <a href="https://web.archive.org/web/20200503051336/http://www.intel.com/content/www/us/en/legal/terms-of-use.html">Terms of Use</a>        </li>
        <li>
          <a href="https://web.archive.org/web/20200503051336/http://www.intel.com/content/www/us/en/legal/trademarks.html">*Trademarks</a>        </li>
        <li>
          <a href="https://web.archive.org/web/20200503051336/https://www.intel.com/content/www/us/en/privacy/intel-privacy-notice.html">Privacy</a>        </li>
        <li>
          <a href="https://web.archive.org/web/20200503051336/http://www.intel.com/content/www/us/en/privacy/intel-cookie-notice.html">Cookies</a>        </li>
        <li>
          <a href="https://web.archive.org/web/20200503051336/https://www.intel.com/content/www/us/en/my-intel/subscription-center.html#/communication-preferences">Email preferences</a>        </li>

      </ul>
    </nav>
  </footer>
</div>
  </div>
<div vocab="http://schema.org/" typeof="TechArticle"><span property="learningResourceType" content="article"></span><span property="headline" content="API without Secrets: Introduction to Vulkan* Part 2: Swap Chain"></span><span property="name" content="API without Secrets: Introduction to Vulkan* Part 2: Swap Chain"></span><div property="author" typeof="Person"><meta property="name" content="Pawel L."></div><span property="datePublished" content="2016-04-05 09:57:03"></span><span property="dateModified" content="2019-11-25 13:50:14"></span><span property="url" content="https://software.intel.com/articles/api-without-secrets-introduction-to-vulkan-part-2"></span><div property="image" typeof="ImageObject"><img class="element-invisible" src="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/search_publish_icon.jpeg" property="url"><meta property="name" content="thumbnail"><meta property="width" content="54"><meta property="height" content="54"></div><span property="inLanguage" content="en"></span><span property="thumbnailURL" content="https://software.intel.com/sites/default/files/d9/e4/search_publish_icon.jpeg"></span><span property="audience" content="20807,Beginner,20808,Intermediate"></span><span property="keywords" content="20787,Linux*,86070,Microsoft Windows*,20802,C/C++,36920,OpenGL*,86573,Vulkan*,85764,Game Development,20864,Graphics,86469,Gameteam"></span>
    <meta property="mainEntityOfPage" href="https://software.intel.com">
      <div property="publisher" typeof="Organization">
      <div property="logo" typeof="ImageObject">
        <img class="element-invisible" src="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/intel_blue.png" property="url">
        <meta property="name" content="thumbnail">
        <meta property="width" content="86">
        <meta property="height" content="60">
      </div>
      <meta property="name" content="Intel">
    </div></div>
  <div class="region region-page-bottom">
    
<!--[if lte IE 9]>
<script> if(jQuery('html.lt-ie10.js')) { jQuery(document).ready(function () {jQuery('form').h5Validate();}); }</script>
<![endif]-->

  </div>
<script src="API%20without%20Secrets_%20Introduction%20to%20Vulkan_%20Part%202_%20Swap%20Chain%20_%20Intel%C2%AE%20Software_files/js_Xg8dVkAiTDNo7NvNdOFzvO8jXSA9esTEOhOwbI61jf4.js"></script>



<deepl-input-controller translate="no"></deepl-input-controller></body></html>
<!--
     FILE ARCHIVED ON 05:13:36 May 03, 2020 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 21:48:24 Sep 10, 2025.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  captures_list: 0.615
  exclusion.robots: 0.027
  exclusion.robots.policy: 0.018
  esindex: 0.01
  cdx.remote: 10.166
  LoadShardBlock: 210.098 (3)
  PetaboxLoader3.datanode: 194.47 (4)
  load_resource: 100.996
  PetaboxLoader3.resolve: 75.48
-->